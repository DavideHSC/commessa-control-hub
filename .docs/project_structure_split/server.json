{
  "name": "server",
  "type": "directory",
  "total_token_estimate": 24689,
  "children": [
    {
      "name": ".eslintrc.json",
      "type": "file",
      "token_estimate": 146,
      "content": "{\n  \"extends\": [\n    \"@typescript-eslint/recommended\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 2020,\n    \"sourceType\": \"module\",\n    \"project\": \"./tsconfig.json\"\n  },\n  \"rules\": {\n    \"@typescript-eslint/no-require-imports\": \"off\",\n    \"@typescript-eslint/no-explicit-any\": \"off\",\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"@typescript-eslint/no-unused-vars\": [\"error\", { \"argsIgnorePattern\": \"^_\" }],\n    \"@typescript-eslint/no-implicit-any-catch\": \"off\"\n  },\n  \"env\": {\n    \"node\": true,\n    \"es6\": true\n  }\n} "
    },
    {
      "name": "index.ts",
      "type": "file",
      "token_estimate": 639,
      "content": "import 'dotenv/config'; // Carica le variabili d'ambiente\nimport express, { Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport { PrismaClient } from '@prisma/client';\n\n// Importa le rotte\nimport clientiRoutes from './routes/clienti';\nimport fornitoriRoutes from './routes/fornitori';\nimport registrazioniRoutes from './routes/registrazioni';\nimport dashboardRoutes from './routes/dashboard';\nimport databaseRoutes from './routes/database';\nimport importScrittureRoutes from './routes/importScritture';\nimport importAnagraficheRoutes from './routes/importAnagrafiche';\nimport causaliRoutes from './routes/causali';\nimport vociAnaliticheRoutes from './routes/vociAnalitiche';\nimport contiRoutes from './routes/conti';\nimport commesseRoutes from './routes/commesse';\nimport importTemplatesRoutes from './routes/importTemplates';\nimport codiciIvaRoutes from './routes/codiciIva';\nimport condizioniPagamentoRoutes from './routes/condizioniPagamento';\nimport { system as systemRoutes } from './routes/system';\n\nconst app = express();\nconst prisma = new PrismaClient();\nconst PORT = process.env.PORT || 3001;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.static('public'));\n\n// Registra le rotte\napp.use('/api/clienti', clientiRoutes);\napp.use('/api/fornitori', fornitoriRoutes);\napp.use('/api/registrazioni', registrazioniRoutes);\napp.use('/api/dashboard', dashboardRoutes);\napp.use('/api/database', databaseRoutes);\napp.use('/api/import/scritture', importScrittureRoutes);\napp.use('/api/import/anagrafica', importAnagraficheRoutes);\napp.use('/api/causali', causaliRoutes);\napp.use('/api/voci-analitiche', vociAnaliticheRoutes);\napp.use('/api/conti', contiRoutes);\napp.use('/api/commesse', commesseRoutes);\napp.use('/api/import-templates', importTemplatesRoutes);\napp.use('/api/codici-iva', codiciIvaRoutes);\napp.use('/api/condizioni-pagamento', condizioniPagamentoRoutes);\napp.use('/api/system', systemRoutes);\n\n\n// Endpoint di base per testare il server\napp.get('/api', (req: Request, res: Response) => {\n  res.json({ message: 'Commessa Control Hub API' });\n});\n\n// Gestione errori globale (esempio base)\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  console.error(err.stack);\n  res.status(500).send('Qualcosa è andato storto!');\n});\n\n// Avvia il server\napp.listen(PORT, () => {\n  console.log(`Server in esecuzione sulla porta ${PORT}`);\n});\n\n// Gestione della chiusura del processo\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n}); "
    },
    {
      "name": "lib",
      "type": "directory",
      "children": [
        {
          "name": "fixedWidthParser.ts",
          "type": "file",
          "token_estimate": 446,
          "content": "/**\n * Definizione di un campo per il parser a larghezza fissa.\n */\nexport interface FieldDefinition {\n  name: string;\n  start: number;\n  length: number;\n  type?: 'string' | 'number' | 'date';\n}\n\n/**\n * Esegue il parsing di una stringa di testo a larghezza fissa.\n */\nexport function parseFixedWidth<T>(\n  content: string,\n  definitions: FieldDefinition[]\n): T[] {\n  const lines = content.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n  const results: T[] = [];\n\n  for (const line of lines) {\n    const parsedObject: { [key: string]: any } = {};\n\n    for (const def of definitions) {\n      const rawValue = line.substring(def.start, def.start + def.length).trim();\n      \n      switch (def.type) {\n        case 'number':\n          parsedObject[def.name] = parseFloat(rawValue.trim().replace(',', '.')) || 0;\n          break;\n        case 'date':\n          // Formato atteso: DDMMYYYY. Gestisce stringhe vuote o non valide.\n          const dateStr = rawValue.trim();\n          if (dateStr && dateStr.length === 8) {\n            const day = parseInt(dateStr.substring(0, 2), 10);\n            const month = parseInt(dateStr.substring(2, 4), 10);\n            const year = parseInt(dateStr.substring(4, 8), 10);\n            \n            if (!isNaN(day) && !isNaN(month) && !isNaN(year) && year > 1900 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {\n              parsedObject[def.name] = new Date(year, month - 1, day);\n            } else {\n              parsedObject[def.name] = null;\n            }\n          } else {\n            parsedObject[def.name] = null;\n          }\n          break;\n        case 'string':\n        default:\n          parsedObject[def.name] = rawValue;\n          break;\n      }\n    }\n    results.push(parsedObject as T);\n  }\n\n  return results;\n} "
        },
        {
          "name": "importUtils.ts",
          "type": "file",
          "token_estimate": 1870,
          "content": "import { Prisma, PrismaClient, TipoConto } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst SYSTEM_CUSTOMER_ID = 'system_customer_01'; // Assicurati che questo ID sia nel seed\nconst SYSTEM_SUPPLIER_ID = 'system_supplier_01';\n\nexport async function processScrittureInBatches(data: { testate: any[], righeContabili: any[], righeIva: any[], allocazioni: any[] }) {\n    const { testate, righeContabili, righeIva, allocazioni } = data;\n    \n    // Mappe dati pre-elaborate per efficienza\n    const testateMap = new Map(testate.map(t => [t.externalId.trim(), t]));\n    const righeContabiliMap = new Map<string, any[]>();\n    righeContabili.forEach(r => {\n        const testataId = r.externalId.substring(0, 12).trim();\n        if (!righeContabiliMap.has(testataId)) righeContabiliMap.set(testataId, []);\n        righeContabiliMap.get(testataId)!.push(r);\n    });\n    const righeIvaMap = new Map<string, any[]>();\n    righeIva.forEach(r => {\n        const rigaId = r.externalId.trim();\n        if (!righeIvaMap.has(rigaId)) righeIvaMap.set(rigaId, []);\n        righeIvaMap.get(rigaId)!.push(r);\n    });\n    const allocazioniMap = new Map<string, any[]>();\n    allocazioni.forEach(a => {\n        const rigaId = a.externalId.trim();\n        if (!allocazioniMap.has(rigaId)) allocazioniMap.set(rigaId, []);\n        allocazioniMap.get(rigaId)!.push(a);\n    });\n\n    let processedCount = 0;\n    let errorCount = 0;\n    const totalBatches = testateMap.size;\n    console.log(`[Import] Inizio elaborazione di ${totalBatches} scritture in batch...`);\n\n    for (const [testataId, testata] of testateMap.entries()) {\n        try {\n            // Ogni testata viene processata in una transazione separata\n            await prisma.$transaction(async (tx) => {\n                const fornitoreId = testata.clienteFornitoreCodiceFiscale?.trim();\n                if (fornitoreId) {\n                    await tx.fornitore.upsert({\n                        where: { id: fornitoreId },\n                        update: {},\n                        create: {\n                            id: fornitoreId,\n                            externalId: fornitoreId,\n                            nome: `Fornitore importato - ${fornitoreId}`\n                        }\n                    });\n                }\n\n                const scritturaData = {\n                    data: testata.dataRegistrazione,\n                    descrizione: `Importazione - ${testataId}`,\n                    causaleId: testata.causaleId.trim(),\n                    dataDocumento: testata.dataDocumento,\n                    numeroDocumento: testata.numeroDocumento.trim(),\n                    fornitoreId: fornitoreId || undefined\n                };\n\n                const scrittura = await tx.scritturaContabile.upsert({\n                    where: { externalId: testataId },\n                    update: scritturaData,\n                    create: { ...scritturaData, externalId: testataId }\n                });\n\n                const righeContabiliPerTestata = righeContabiliMap.get(testataId) || [];\n                for (const riga of righeContabiliPerTestata) {\n                    const rigaId = riga.externalId.trim();\n                    const contoId = riga.conto.trim();\n                    if (!contoId) continue;\n\n                    await tx.conto.upsert({\n                        where: { id: contoId },\n                        update: {},\n                        create: {\n                            id: contoId,\n                            codice: contoId,\n                            nome: `Conto importato - ${contoId}`,\n                            tipo: TipoConto.Patrimoniale,\n                            richiedeVoceAnalitica: false,\n                        }\n                    });\n\n                    const rigaScrittura = await tx.rigaScrittura.create({\n                        data: {\n                            scritturaContabileId: scrittura.id,\n                            descrizione: riga.note.trim(),\n                            dare: riga.importoDare,\n                            avere: riga.importoAvere,\n                            contoId: contoId,\n                        }\n                    });\n\n                    const righeIvaPerRiga = righeIvaMap.get(rigaId) || [];\n                    for (const rigaIva of righeIvaPerRiga) {\n                        const codiceIvaId = rigaIva.codiceIva.trim();\n                        if (!codiceIvaId) continue;\n                        await tx.codiceIva.upsert({\n                            where: { id: codiceIvaId },\n                            update: {},\n                            create: {\n                                id: codiceIvaId,\n                                descrizione: `IVA importata - ${codiceIvaId}`,\n                                aliquota: 0,\n                            }\n                        });\n                        await tx.rigaIva.create({\n                            data: {\n                                rigaScritturaId: rigaScrittura.id,\n                                imponibile: rigaIva.imponibile,\n                                imposta: rigaIva.imposta,\n                                codiceIvaId: codiceIvaId,\n                            }\n                        });\n                    }\n\n                    const allocazioniPerRiga = allocazioniMap.get(rigaId) || [];\n                    for (const alloc of allocazioniPerRiga) {\n                        const commessaId = alloc.centroDiCosto.trim();\n                        const voceAnaliticaId = alloc.parametro.toString().trim();\n                        if (!commessaId || !voceAnaliticaId) continue;\n\n                        await tx.voceAnalitica.upsert({\n                            where: { id: voceAnaliticaId },\n                            update: {},\n                            create: {\n                                id: voceAnaliticaId,\n                                nome: `Voce importata - ${voceAnaliticaId}`\n                            }\n                        });\n\n                        await tx.commessa.upsert({\n                            where: { id: commessaId },\n                            update: {},\n                            create: {\n                                id: commessaId,\n                                nome: `Commessa importata - ${commessaId}`,\n                                clienteId: SYSTEM_CUSTOMER_ID\n                            }\n                        });\n\n                        await tx.allocazione.create({\n                            data: {\n                                rigaScritturaId: rigaScrittura.id,\n                                importo: alloc.parametro,\n                                commessaId: commessaId,\n                                voceAnaliticaId: voceAnaliticaId, \n                            }\n                        });\n                    }\n                }\n            });\n            processedCount++;\n            if (processedCount % 100 === 0) {\n                console.log(`[Import] Progresso: ${processedCount} / ${totalBatches} scritture elaborate...`);\n            }\n        } catch (error) {\n            console.error(`[Import] Errore durante l'elaborazione della testata ${testataId}. Questo record sarà saltato. Dettagli:`, error);\n            errorCount++;\n        }\n    }\n\n    console.log(`[Import] Elaborazione batch completata. Successo: ${processedCount}, Errori: ${errorCount}.`);\n    return { processedCount, errorCount };\n} "
        },
        {
          "name": "jobManager.ts",
          "type": "file",
          "token_estimate": 368,
          "content": "import { EventEmitter } from 'events';\n\nexport type JobStatus = 'pending' | 'processing' | 'completed' | 'failed';\n\nexport interface Job {\n  id: string;\n  status: JobStatus;\n  progress: number;\n  total: number;\n  message: string;\n  result?: any;\n  error?: string;\n}\n\n// Usiamo un EventEmitter per notificare gli aggiornamenti di stato\nclass JobManager extends EventEmitter {\n  private jobs = new Map<string, Job>();\n\n  create(jobId: string, total: number) {\n    const job: Job = {\n      id: jobId,\n      status: 'pending',\n      progress: 0,\n      total,\n      message: 'In attesa di avvio...',\n    };\n    this.jobs.set(jobId, job);\n    this.emit('update', job);\n    return job;\n  }\n\n  update(jobId: string, updates: Partial<Job>) {\n    const job = this.jobs.get(jobId);\n    if (!job) return;\n\n    // Aggiorna solo i campi forniti\n    const updatedJob = { ...job, ...updates };\n    this.jobs.set(jobId, updatedJob);\n    \n    // Emetti un evento per notificare i listener (il nostro endpoint SSE)\n    this.emit('update', updatedJob);\n  }\n\n  get(jobId: string): Job | undefined {\n    return this.jobs.get(jobId);\n  }\n\n  cleanup(jobId: string) {\n    // Rimuovi i job completati dopo un po' per non riempire la memoria\n    setTimeout(() => {\n      this.jobs.delete(jobId);\n      console.log(`[JobManager] Pulito job ${jobId}`);\n    }, 60 * 1000); // 1 minuto\n  }\n}\n\n// Esportiamo una singola istanza (singleton) del nostro manager\nexport const jobManager = new JobManager(); "
        }
      ]
    },
    {
      "name": "routes",
      "type": "directory",
      "children": [
        {
          "name": "causali.ts",
          "type": "file",
          "token_estimate": 850,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutte le causali contabili\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n        page = '1', \n        limit = '25', \n        search = '',\n        sortBy = 'nome',\n        sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.CausaleContabileWhereInput = search ? {\n        OR: [\n            { nome: { contains: search as string, mode: 'insensitive' } },\n            { descrizione: { contains: search as string, mode: 'insensitive' } },\n            { externalId: { contains: search as string, mode: 'insensitive' } },\n        ],\n    } : {};\n\n    const orderBy: Prisma.CausaleContabileOrderByWithRelationInput = {\n        [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n\n    const [causali, totalCount] = await prisma.$transaction([\n        prisma.causaleContabile.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n            include: {\n                datiPrimari: true,\n                templateScrittura: true,\n            },\n        }),\n        prisma.causaleContabile.count({ where }),\n    ]);\n    \n    res.json({\n        data: causali,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n\n  } catch (error) {\n    console.error('Errore nel caricamento delle causali contabili:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea una nuova causale contabile\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, nome, descrizione, externalId } = req.body;\n    \n    const causale = await prisma.causaleContabile.create({\n      data: {\n        id,\n        nome,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(causale);\n  } catch (error) {\n    console.error('Errore nella creazione della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna una causale contabile esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { nome, descrizione, externalId } = req.body;\n    \n    const causale = await prisma.causaleContabile.update({\n      where: { id },\n      data: {\n        nome,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(causale);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina una causale contabile\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.causaleContabile.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "clienti.ts",
          "type": "file",
          "token_estimate": 1107,
          "content": "import express, { Router, Request, Response } from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\n\nconst router = Router();\nconst prisma = new PrismaClient();\n\n// Funzione helper per gestire gli errori Prisma\nconst isPrismaError = (error: unknown): error is PrismaClientKnownRequestError => {\n    return error instanceof PrismaClientKnownRequestError;\n};\n\n// GET - Recupera tutti i clienti con paginazione\nrouter.get('/', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { \n      page = '1', \n      limit = '25', \n      search = '',\n      sortBy = 'nome',\n      sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.ClienteWhereInput = search ? {\n      OR: [\n        { nome: { contains: search as string, mode: 'insensitive' } },\n        { externalId: { contains: search as string, mode: 'insensitive' } },\n        { piva: { contains: search as string, mode: 'insensitive' } },\n        { codiceFiscale: { contains: search as string, mode: 'insensitive' } },\n      ],\n    } : {};\n\n    const orderBy: Prisma.ClienteOrderByWithRelationInput = {\n        [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n    \n    const [clienti, totalCount] = await prisma.$transaction([\n        prisma.cliente.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n        }),\n        prisma.cliente.count({ where }),\n    ]);\n\n    res.json({\n        data: clienti,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n  } catch (error) {\n    console.error('Errore nel recupero dei clienti:', error);\n    res.status(500).json({ error: \"Errore durante il recupero dei clienti.\" });\n  }\n});\n\n// --- CRUD Clienti ---\nrouter.post('/', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome è obbligatorio' });\n      return;\n    }\n    const nuovoCliente = await prisma.cliente.create({\n      data: {\n        nome,\n        externalId,\n      },\n    });\n    res.status(201).json(nuovoCliente);\n  } catch (error) {\n    console.error('Errore nella creazione del cliente:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {\n      res.status(409).json({ error: 'Un cliente con questa P.IVA o nome esiste già.' });\n      return;\n    }\n    res.status(500).json({ error: \"Errore durante la creazione del cliente.\" });\n  }\n});\n\nrouter.put('/:id', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { id } = req.params;\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome è obbligatorio' });\n      return;\n    }\n    const clienteAggiornato = await prisma.cliente.update({\n      where: { id },\n      data: {\n        nome,\n        externalId,\n      },\n    });\n    res.json(clienteAggiornato);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del cliente:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {\n        res.status(404).json({ error: 'Cliente non trovato.' });\n        return;\n    }\n    res.status(500).json({ error: \"Errore durante l'aggiornamento del cliente.\" });\n  }\n});\n\nrouter.delete('/:id', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { id } = req.params;\n    await prisma.cliente.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    if (error instanceof PrismaClientKnownRequestError) {\n      if (error.code === 'P2025') {\n          res.status(404).json({ error: 'Cliente non trovato.' });\n          return;\n      }\n      if (error.code === 'P2003') {\n        res.status(409).json({ error: 'Impossibile eliminare il cliente perché è associato ad almeno una commessa.' });\n        return;\n      }\n    }\n    console.error('Errore nell\\'eliminazione del cliente:', error);\n    res.status(500).json({ error: \"Errore durante l'eliminazione del cliente.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "codiciIva.ts",
          "type": "file",
          "token_estimate": 807,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutti i codici IVA\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n        page = '1', \n        limit = '25', \n        search = '',\n        sortBy = 'id',\n        sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.CodiceIvaWhereInput = search ? {\n        OR: [\n            { id: { contains: search as string, mode: 'insensitive' } },\n            { descrizione: { contains: search as string, mode: 'insensitive' } },\n            { externalId: { contains: search as string, mode: 'insensitive' } },\n        ],\n    } : {};\n\n    const orderBy: Prisma.CodiceIvaOrderByWithRelationInput = {\n        [(sortBy as string) || 'id']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n\n    const [codiciIva, totalCount] = await prisma.$transaction([\n        prisma.codiceIva.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n        }),\n        prisma.codiceIva.count({ where }),\n    ]);\n\n    res.json({\n        data: codiciIva,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n  } catch (error) {\n    console.error('Errore nel caricamento dei codici IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea un nuovo codice IVA\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, descrizione, aliquota, externalId } = req.body;\n    \n    const codiceIva = await prisma.codiceIva.create({\n      data: {\n        id,\n        descrizione,\n        aliquota: parseFloat(aliquota),\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(codiceIva);\n  } catch (error) {\n    console.error('Errore nella creazione del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna un codice IVA esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { descrizione, aliquota, externalId } = req.body;\n    \n    const codiceIva = await prisma.codiceIva.update({\n      where: { id },\n      data: {\n        descrizione,\n        aliquota: parseFloat(aliquota),\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(codiceIva);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina un codice IVA\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.codiceIva.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "commesse.ts",
          "type": "file",
          "token_estimate": 905,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all commesse with pagination\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n      page = '1', \n      limit = '25', \n      search = '',\n      sortBy = 'nome',\n      sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.CommessaWhereInput = search ? {\n      OR: [\n        { nome: { contains: search as string, mode: 'insensitive' } },\n        { descrizione: { contains: search as string, mode: 'insensitive' } },\n        { cliente: { nome: { contains: search as string, mode: 'insensitive' } } },\n      ],\n    } : {};\n\n    const orderBy: Prisma.CommessaOrderByWithRelationInput = {\n        [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n\n    const [commesse, totalCount] = await prisma.$transaction([\n      prisma.commessa.findMany({\n        where,\n        orderBy,\n        skip,\n        take,\n        include: { \n          cliente: true, \n          budget: true \n        }\n      }),\n      prisma.commessa.count({ where })\n    ]);\n    \n    res.json({\n        data: commesse,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel recupero delle commesse.' });\n  }\n});\n\n// POST a new commessa\nrouter.post('/', async (req, res) => {\n  try {\n    const { budget, ...commessaData } = req.body;\n    const nuovaCommessa = await prisma.commessa.create({\n      data: {\n        ...commessaData,\n        budget: {\n          create: budget || [], // budget è un array di BudgetVoce\n        }\n      },\n    });\n    res.status(201).json(nuovaCommessa);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Errore nella creazione della commessa.' });\n  }\n});\n\n// PUT update a commessa\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const { budget, cliente, ...commessaData } = req.body;\n    \n    // Iniziamo una transazione per aggiornare la commessa e il suo budget\n    const result = await prisma.$transaction(async (tx) => {\n      // 1. Aggiorna i dati base della commessa\n      const commessaAggiornata = await tx.commessa.update({\n        where: { id },\n        data: commessaData,\n      });\n\n      // 2. Se è stato fornito un nuovo budget, cancelliamo quello vecchio e creiamo quello nuovo\n      if (budget) {\n        await tx.budgetVoce.deleteMany({\n          where: { commessaId: id },\n        });\n        await tx.budgetVoce.createMany({\n          data: budget.map((voce: any) => ({\n            ...voce,\n            commessaId: id,\n          })),\n        });\n      }\n\n      return commessaAggiornata;\n    });\n\n    res.json(result);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: `Errore nell'aggiornamento della commessa ${id}.` });\n  }\n});\n\n// DELETE a commessa\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    // La cancellazione a cascata dovrebbe gestire il budget associato\n    await prisma.commessa.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione della commessa ${id}.` });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "condizioniPagamento.ts",
          "type": "file",
          "token_estimate": 846,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutte le condizioni di pagamento\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n        page = '1', \n        limit = '25', \n        search = '',\n        sortBy = 'id',\n        sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.CondizionePagamentoWhereInput = search ? {\n        OR: [\n            { id: { contains: search as string, mode: 'insensitive' } },\n            { descrizione: { contains: search as string, mode: 'insensitive' } },\n            { externalId: { contains: search as string, mode: 'insensitive' } },\n        ],\n    } : {};\n\n    const orderBy: Prisma.CondizionePagamentoOrderByWithRelationInput = {\n        [(sortBy as string) || 'id']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n    \n    const [condizioniPagamento, totalCount] = await prisma.$transaction([\n        prisma.condizionePagamento.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n        }),\n        prisma.condizionePagamento.count({ where }),\n    ]);\n    \n    res.json({\n        data: condizioniPagamento,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n  } catch (error) {\n    console.error('Errore nel caricamento delle condizioni di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea una nuova condizione di pagamento\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, descrizione, externalId } = req.body;\n    \n    const condizionePagamento = await prisma.condizionePagamento.create({\n      data: {\n        id,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(condizionePagamento);\n  } catch (error) {\n    console.error('Errore nella creazione della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna una condizione di pagamento esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { descrizione, externalId } = req.body;\n    \n    const condizionePagamento = await prisma.condizionePagamento.update({\n      where: { id },\n      data: {\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(condizionePagamento);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina una condizione di pagamento\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.condizionePagamento.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "conti.ts",
          "type": "file",
          "token_estimate": 612,
          "content": "import express from 'express';\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all conti with pagination, search, and sort\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n      page = '1', \n      limit = '25', \n      search = '',\n      sortBy = 'codice',\n      sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.ContoWhereInput = search ? {\n      OR: [\n        { codice: { contains: search as string, mode: 'insensitive' } },\n        { nome: { contains: search as string, mode: 'insensitive' } },\n      ],\n    } : {};\n\n    const orderBy: Prisma.ContoOrderByWithRelationInput = {\n        [(sortBy as string) || 'codice']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n\n    const [conti, totalCount] = await prisma.$transaction([\n      prisma.conto.findMany({\n        where,\n        orderBy,\n        skip,\n        take,\n      }),\n      prisma.conto.count({ where }),\n    ]);\n\n    res.json({\n      data: conti,\n      pagination: {\n        page: pageNumber,\n        limit: pageSize,\n        total: totalCount,\n        totalPages: Math.ceil(totalCount / pageSize),\n      }\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Errore nel recupero dei conti.' });\n  }\n});\n\n// POST a new conto\nrouter.post('/', async (req, res) => {\n  try {\n    const nuovoConto = await prisma.conto.create({\n      data: req.body,\n    });\n    res.status(201).json(nuovoConto);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nella creazione del conto.' });\n  }\n});\n\n// PUT update a conto\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const contoAggiornato = await prisma.conto.update({\n      where: { id },\n      data: req.body,\n    });\n    res.json(contoAggiornato);\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'aggiornamento del conto ${id}.` });\n  }\n});\n\n// DELETE a conto\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    await prisma.conto.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione del conto ${id}.` });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "dashboard.ts",
          "type": "file",
          "token_estimate": 733,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\n// Tipi incollati da src/types/index.ts per risolvere l'errore di rootDir\ninterface CommessaDashboard {\n  id: string;\n  nome: string;\n  cliente: {\n    id: string;\n    nome: string;\n  };\n  stato: string;\n  ricavi: number;\n  costi: number;\n  margine: number;\n  budget: number;\n}\n\ninterface DashboardData {\n  commesse: CommessaDashboard[];\n  kpi: {\n    commesseAttive: number;\n    ricaviTotali: number;\n    costiTotali: number;\n    margineLordoMedio: number;\n  };\n}\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\nrouter.get('/', async (req, res) => {\n  try {\n    const commesse = await prisma.commessa.findMany({\n      include: {\n        cliente: true,\n        budget: {\n          include: {\n            voceAnalitica: true,\n          },\n        },\n        allocazioni: {\n          include: {\n            rigaScrittura: true,\n          },\n        },\n      },\n    });\n\n    const scritture = await prisma.scritturaContabile.findMany({\n      include: {\n        righe: {\n          include: {\n            conto: true,\n            allocazioni: {\n              include: {\n                commessa: true,\n                voceAnalitica: true,\n              }\n            }\n          }\n        }\n      }\n    });\n\n    const commesseDashboard: CommessaDashboard[] = commesse.map(c => {\n      const budgetTotale = c.budget.reduce((acc, b) => acc + b.importo, 0);\n      \n      const costi = scritture.flatMap(s => s.righe)\n        .filter(r => r.conto.tipo === 'Costo' && r.allocazioni.some(a => a.commessaId === c.id))\n        .reduce((acc, r) => acc + r.dare, 0);\n\n      const ricavi = scritture.flatMap(s => s.righe)\n        .filter(r => r.conto.tipo === 'Ricavo' && r.allocazioni.some(a => a.commessaId === c.id))\n        .reduce((acc, r) => acc + r.avere, 0);\n\n      const margine = ricavi > 0 ? ((ricavi - costi) / ricavi) * 100 : 0;\n\n      return {\n        id: c.id,\n        nome: c.nome,\n        cliente: {\n            id: c.cliente.id,\n            nome: c.cliente.nome,\n        },\n        stato: 'In Corso',\n        ricavi: ricavi,\n        costi: costi,\n        margine: margine,\n        budget: budgetTotale\n      };\n    });\n\n    const ricaviTotali = commesseDashboard.reduce((acc, c) => acc + c.ricavi, 0);\n    const costiTotali = commesseDashboard.reduce((acc, c) => acc + c.costi, 0);\n    const margineLordoMedio = ricaviTotali > 0 ? ((ricaviTotali - costiTotali) / ricaviTotali) * 100 : 0;\n\n    const dashboardData: DashboardData = {\n      kpi: {\n        commesseAttive: commesse.length,\n        ricaviTotali,\n        costiTotali,\n        margineLordoMedio,\n      },\n      commesse: commesseDashboard,\n    };\n\n    res.json(dashboardData);\n  } catch (error) {\n    console.error(\"Errore nel recupero dati per la dashboard:\", error);\n    res.status(500).json({ message: \"Errore interno del server.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "database.ts",
          "type": "file",
          "token_estimate": 617,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\nrouter.get('/', async (req, res) => {\n  try {\n    const [\n      scritture,\n      commesse,\n      clienti,\n      fornitori,\n      conti,\n      vociAnalitiche,\n      causali,\n      codiciIva,\n      condizioniPagamento,\n    ] = await prisma.$transaction([\n      prisma.scritturaContabile.findMany({\n        include: {\n          righe: true\n        },\n        orderBy: {\n            data: 'desc'\n        }\n      }),\n      prisma.commessa.findMany(),\n      prisma.cliente.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.fornitore.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.conto.findMany({ orderBy: { codice: 'asc' } }),\n      prisma.voceAnalitica.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.causaleContabile.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.codiceIva.findMany({ orderBy: { id: 'asc' } }),\n      prisma.condizionePagamento.findMany({ orderBy: { id: 'asc' } }),\n    ]);\n\n    const stats = {\n      totaleScrittureContabili: scritture.length,\n      totaleCommesse: commesse.length,\n      totaleClienti: clienti.length,\n      totaleFornitori: fornitori.length,\n      totaleConti: conti.length,\n      totaleVociAnalitiche: vociAnalitiche.length,\n      totaleCausali: causali.length,\n      totaleCodiciIva: codiciIva.length,\n      totaleCondizioniPagamento: condizioniPagamento.length,\n    };\n\n    res.json({\n      scritture,\n      commesse,\n      clienti,\n      fornitori,\n      conti,\n      vociAnalitiche,\n      causali,\n      codiciIva,\n      condizioniPagamento,\n      stats,\n    });\n  } catch (error) {\n    console.error('Errore nel recupero dei dati del database:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nrouter.delete('/scritture', async (req, res) => {\n  try {\n    await prisma.$transaction(async (tx) => {\n      await tx.allocazione.deleteMany({});\n      await tx.rigaIva.deleteMany({});\n      await tx.rigaScrittura.deleteMany({});\n      await tx.scritturaContabile.deleteMany({});\n    });\n    res.status(200).json({ message: 'Tabella Scritture Contabili svuotata con successo.' });\n  } catch (error) {\n    console.error(\"Errore durante lo svuotamento della tabella Scritture Contabili:\", error);\n    res.status(500).json({ error: 'Errore interno del server durante la pulizia delle scritture.' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "fornitori.ts",
          "type": "file",
          "token_estimate": 1121,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// Funzione helper per gestire gli errori Prisma\nconst isPrismaError = (error: unknown): error is PrismaClientKnownRequestError => {\n    return error instanceof PrismaClientKnownRequestError;\n};\n\n// GET - Recupera tutti i fornitori con paginazione\nrouter.get('/', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    const { \n      page = '1', \n      limit = '25', \n      search = '',\n      sortBy = 'nome',\n      sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.FornitoreWhereInput = search ? {\n      OR: [\n        { nome: { contains: search as string, mode: 'insensitive' } },\n        { externalId: { contains: search as string, mode: 'insensitive' } },\n        { piva: { contains: search as string, mode: 'insensitive' } },\n        { codiceFiscale: { contains: search as string, mode: 'insensitive' } },\n      ],\n    } : {};\n\n    const orderBy: Prisma.FornitoreOrderByWithRelationInput = {\n        [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n    \n    const [fornitori, totalCount] = await prisma.$transaction([\n        prisma.fornitore.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n        }),\n        prisma.fornitore.count({ where }),\n    ]);\n\n    res.json({\n        data: fornitori,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n  } catch (error) {\n    console.error('Errore nel recupero dei fornitori:', error);\n    res.status(500).json({ error: \"Errore durante il recupero dei fornitori.\" });\n  }\n});\n\n// --- CRUD Fornitori ---\nrouter.post('/', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome è obbligatorio' });\n      return;\n    }\n    const nuovoFornitore = await prisma.fornitore.create({ \n      data: {\n        nome,\n        externalId\n      }\n    });\n    res.status(201).json(nuovoFornitore);\n  } catch (error) {\n    console.error('Errore nella creazione del fornitore:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {\n      res.status(409).json({ error: 'Un fornitore con questa P.IVA o nome esiste già.' });\n      return;\n    }\n    res.status(500).json({ error: \"Errore durante la creazione del fornitore.\" });\n  }\n});\n\nrouter.put('/:id', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome è obbligatorio' });\n      return;\n    }\n    const fornitoreAggiornato = await prisma.fornitore.update({\n      where: { id: req.params.id },\n      data: {\n        nome,\n        externalId\n      },\n    });\n    res.json(fornitoreAggiornato);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del fornitore:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {\n        res.status(404).json({ error: 'Fornitore non trovato.' });\n        return;\n    }\n    res.status(500).json({ error: \"Errore durante l'aggiornamento del fornitore.\" });\n  }\n});\n\nrouter.delete('/:id', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    await prisma.fornitore.delete({ where: { id: req.params.id } });\n    res.status(204).send();\n  } catch (error) {\n    if (error instanceof PrismaClientKnownRequestError) {\n      if (error.code === 'P2025') {\n          res.status(404).json({ error: 'Fornitore non trovato.' });\n          return;\n      }\n      if (error.code === 'P2003') {\n        res.status(409).json({ error: 'Impossibile eliminare il fornitore perché è utilizzato in una o più registrazioni.' });\n        return;\n      }\n    }\n    console.error('Errore nell\\'eliminazione del fornitore:', error);\n    res.status(500).json({ error: \"Errore durante l'eliminazione del fornitore.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "importAnagrafiche.ts",
          "type": "file",
          "token_estimate": 3981,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient, Prisma, TipoConto } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\nimport { jobManager } from '../lib/jobManager';\nimport { randomUUID } from 'crypto';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// Funzione per tracciare gli step del wizard\nconst trackWizardStep = async (templateName: string, status: string, fileName?: string, recordCount?: number, error?: string) => {\n    const stepMapping: Record<string, { stepId: string, stepTitle: string }> = {\n        'piano_dei_conti': { stepId: 'conti', stepTitle: 'Piano dei Conti' },\n        'anagrafica_clifor': { stepId: 'clienti', stepTitle: 'Clienti e Fornitori' },\n        'causali': { stepId: 'causali', stepTitle: 'Causali Contabili' }\n    };\n\n    const stepInfo = stepMapping[templateName];\n    if (!stepInfo) return;\n\n    try {\n        const data = {\n            stepId: stepInfo.stepId,\n            stepTitle: stepInfo.stepTitle,\n            templateName: templateName,\n            status: status,\n            fileName: fileName,\n            recordCount: recordCount,\n            completedAt: status === 'completed' ? new Date() : null,\n            error: error\n        };\n\n        await prisma.wizardStep.upsert({\n            where: { stepId: stepInfo.stepId },\n            update: data,\n            create: {\n                ...data,\n                startedAt: new Date()\n            },\n        });\n    } catch (err) {\n        console.error(`Errore nel tracciamento wizard step per ${templateName}:`, err);\n    }\n};\n\n// Funzione principale che esegue l'importazione\nconst runAnagraficaImportJob = async (jobId: string, templateName: string, fileContent: string, fileName?: string) => {\n    try {\n        jobManager.update(jobId, { status: 'processing', message: 'Recupero il template...' });\n\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: templateName },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            throw new Error(`Template '${templateName}' non trovato.`);\n        }\n\n        const modelName = (importTemplate as any).modelName as keyof PrismaClient;\n        const fieldDefinitions = importTemplate.fields.map(f => ({ name: f.nomeCampo, start: f.start, length: f.length, type: f.type as any }));\n        const parsedData = parseFixedWidth<any>(fileContent, fieldDefinitions);\n        const totalRecords = parsedData.length;\n        jobManager.update(jobId, { total: totalRecords, message: `Trovati ${totalRecords} record. Inizio elaborazione...` });\n        \n        // Gestione per Anagrafica Clienti/Fornitori (A_CLIFOR.TXT)\n        if (templateName === 'anagrafica_clifor') {\n            const logs: string[] = [];\n            \n            // Rimuoviamo la transazione globale per isolare gli errori riga per riga\n            for (const record of parsedData) {\n                const externalId = record.externalId?.trim();\n                if (!externalId) continue;\n\n                const piva = record.piva?.trim();\n                const dataToUpsert = {\n                    externalId: externalId,\n                    nome: record.nome?.trim() || 'N/A',\n                    piva: piva,\n                    codiceFiscale: record.codiceFiscale?.trim(),\n                };\n                \n                const tipoAnagrafica = record.tipo?.trim().toUpperCase();\n\n                const processEntity = async (entityType: 'cliente' | 'fornitore') => {\n                    try {\n                        // Usiamo la P.IVA come chiave primaria se presente, altrimenti externalId\n                        const whereClause = piva \n                            ? { piva: piva }\n                            : { externalId: externalId };\n                            \n                        await (prisma as any)[entityType].upsert({\n                            where: whereClause,\n                            update: dataToUpsert,\n                            create: dataToUpsert,\n                        });\n                        \n                        logs.push(`SUCCESS: Record ${externalId} (${entityType}) elaborato con successo${piva ? ` [P.IVA: ${piva}]` : ''}`);\n                    } catch (e: any) {\n                        if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2002') {\n                            logs.push(`WARN: Record ${externalId} (${entityType}) saltato per violazione di unicità - probabilmente P.IVA duplicata`);\n                        } else {\n                            const errorMessage = e.message || String(e);\n                            logs.push(`ERROR: Record ${externalId} (${entityType}) fallito: ${errorMessage}`);\n                        }\n                    }\n                };\n\n                if (tipoAnagrafica === 'C' || tipoAnagrafica === 'E') {\n                    await processEntity('cliente');\n                }\n\n                if (tipoAnagrafica === 'F' || tipoAnagrafica === 'E') {\n                    await processEntity('fornitore');\n                }\n            }\n\n            console.log(\"Log di importazione anagrafiche:\", logs);\n            const hasErrors = logs.some(log => log.startsWith('ERROR'));\n            \n            // Traccia lo step del wizard\n            await trackWizardStep(templateName, hasErrors ? 'failed' : 'completed', fileName, totalRecords, hasErrors ? logs.join('\\n') : undefined);\n            \n            if (hasErrors) {\n                const errorMessage = 'Importazione completata con errori. Controllare i log.';\n                jobManager.update(jobId, { status: 'failed', progress: totalRecords, message: errorMessage, error: logs.join('\\n') });\n            } else {\n                jobManager.update(jobId, { status: 'completed', progress: totalRecords, message: 'Importazione completata con successo.' });\n            }\n            \n            jobManager.cleanup(jobId);\n            return { status: hasErrors ? 'FAILED' : 'SUCCESS', logs };\n        }\n\n        // Gestione per Piano dei Conti (CONTIGEN.TXT)\n        if (templateName === 'piano_dei_conti') {\n            const batchSize = 100;\n            let processedCount = 0;\n            for (let i = 0; i < parsedData.length; i += batchSize) {\n                const batch = parsedData.slice(i, i + batchSize);\n                await prisma.$transaction(async (tx) => {\n                    for (const record of batch) {\n                        // Mappa il tipo carattere a TipoConto enum\n                        let tipo: TipoConto;\n                        const tipoChar = record.tipoChar?.trim();\n                        switch (tipoChar) {\n                            case 'P': \n                                tipo = TipoConto.Patrimoniale; \n                                break;\n                            case 'E': \n                                // Per i conti economici, distingui tra ricavi (classe 1) e costi (altre classi)\n                                tipo = record.codice?.trim().startsWith('1') ? TipoConto.Ricavo : TipoConto.Costo; \n                                break;\n                            case 'C': \n                                tipo = TipoConto.Cliente; \n                                break;\n                            case 'F': \n                                tipo = TipoConto.Fornitore; \n                                break;\n                            default: \n                                tipo = TipoConto.Patrimoniale; \n                                break;\n                        }\n\n                        const dataToUpsert = {\n                            id: record.codice?.trim(),\n                            externalId: record.codice?.trim(),\n                            codice: record.codice?.trim(),\n                            nome: record.nome?.trim() || 'Conto senza nome',\n                            tipo: tipo,\n                            richiedeVoceAnalitica: false,\n                            vociAnaliticheAbilitateIds: [],\n                            contropartiteSuggeriteIds: []\n                        };\n\n                        await tx.conto.upsert({\n                            where: { id: record.codice?.trim() },\n                            update: dataToUpsert,\n                            create: { ...dataToUpsert, id: record.codice?.trim() }\n                        });\n                    }\n                });\n                processedCount += batch.length;\n                jobManager.update(jobId, { progress: processedCount, message: `Elaborati ${processedCount} di ${totalRecords} conti...` });\n            }\n            \n            console.log(`✅ IMPORTAZIONE COMPLETATA: ${processedCount} conti salvati nel database su ${parsedData.length} record totali`);\n            \n            // Traccia lo step del wizard\n            await trackWizardStep(templateName, 'completed', fileName, processedCount);\n            \n            jobManager.update(jobId, { status: 'completed', progress: processedCount, message: 'Importazione completata con successo.' });\n            jobManager.cleanup(jobId);\n            return { status: 'SUCCESS', rowCount: processedCount };\n        }\n\n        // Gestione per Causali Contabili (CAUSALI.TXT)\n        if (templateName === 'causali') {\n            const logs: string[] = [];\n            let processedCount = 0;\n            \n            for (const record of parsedData) {\n                const externalId = record.externalId?.trim();\n                if (!externalId) continue;\n\n                try {\n                    const dataToUpsert = {\n                        id: externalId,\n                        externalId: externalId,\n                        nome: record.nome?.trim() || 'Causale senza nome',\n                        descrizione: record.noteMovimento?.trim() || record.nome?.trim() || 'Causale importata'\n                    };\n\n                    await prisma.causaleContabile.upsert({\n                        where: { id: externalId },\n                        update: dataToUpsert,\n                        create: dataToUpsert\n                    });\n                    \n                    processedCount++;\n                    logs.push(`SUCCESS: Causale ${externalId} elaborata con successo`);\n                    \n                    if (processedCount % 50 === 0) {\n                        jobManager.update(jobId, { progress: processedCount, message: `Elaborate ${processedCount} di ${totalRecords} causali...` });\n                    }\n                } catch (e: any) {\n                    if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2002') {\n                        logs.push(`WARN: Causale ${externalId} saltata per violazione di unicità`);\n                    } else {\n                        const errorMessage = e.message || String(e);\n                        logs.push(`ERROR: Causale ${externalId} fallita: ${errorMessage}`);\n                    }\n                }\n            }\n\n            console.log(\"Log di importazione causali:\", logs);\n            const hasErrors = logs.some(log => log.startsWith('ERROR'));\n            \n            // Traccia lo step del wizard\n            await trackWizardStep(templateName, hasErrors ? 'failed' : 'completed', fileName, processedCount, hasErrors ? logs.join('\\n') : undefined);\n            \n            if (hasErrors) {\n                const errorMessage = 'Importazione completata con errori. Controllare i log.';\n                jobManager.update(jobId, { status: 'failed', progress: processedCount, message: errorMessage, error: logs.join('\\n') });\n            } else {\n                jobManager.update(jobId, { status: 'completed', progress: processedCount, message: 'Importazione completata con successo.' });\n            }\n            \n            jobManager.cleanup(jobId);\n            return { status: hasErrors ? 'FAILED' : 'SUCCESS', logs, rowCount: processedCount };\n        }\n\n        if (!modelName || !(prisma as any)[modelName]) {\n            throw new Error(`Il nome del modello per '${templateName}' non è valido o non è configurato.`);\n        }\n\n        // Esegui il parsing e il salvataggio per anagrafiche generiche\n        await prisma.$transaction(async (tx) => {\n            for (const record of parsedData) {\n                const dataToUpsert: any = { ...record };\n                Object.keys(dataToUpsert).forEach(key => {\n                    if (typeof dataToUpsert[key] === 'string') {\n                        dataToUpsert[key] = dataToUpsert[key].trim();\n                    }\n                    // Gestione specifica per aliquote/valori numerici che potrebbero richiedere una divisione\n                    if (key === 'aliquota' && typeof dataToUpsert[key] === 'number' && dataToUpsert[key] > 1000) {\n                         // Esempio da file fisso: 2200 -> 22.00. Dividiamo per 100\n                        dataToUpsert[key] = dataToUpsert[key] / 100;\n                    }\n                });\n\n                // Per le anagrafiche standard, usiamo externalId come chiave primaria\n                const primaryKey = dataToUpsert.externalId;\n                if (!primaryKey) {\n                    console.warn('Record saltato per mancanza di externalId:', record);\n                    continue;\n                }\n\n                // Mappiamo externalId sul campo 'id' che è la chiave del modello\n                dataToUpsert.id = primaryKey;\n\n                await (tx as any)[modelName].upsert({\n                    where: { id: primaryKey },\n                    update: dataToUpsert,\n                    create: dataToUpsert,\n                });\n            }\n        });\n\n        jobManager.update(jobId, { status: 'completed', progress: totalRecords, message: 'Importazione completata con successo.' });\n        jobManager.cleanup(jobId);\n        return { status: 'SUCCESS', rowCount: totalRecords };\n\n    } catch (e: unknown) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        jobManager.update(jobId, { status: 'failed', error: error.message, message: 'Importazione fallita.' });\n        jobManager.cleanup(jobId);\n        return { status: 'FAILED', error: error.message };\n    }\n}\n\n// Endpoint per AVVIARE l'importazione\nrouter.post('/:templateName', upload.single('file'), async (req: Request, res: Response) => {\n    const { templateName } = req.params;\n\n    if (!req.file) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n\n    const fileContent = req.file.buffer.toString('utf-8');\n    const jobId = randomUUID();\n\n    // Crea il job\n    jobManager.create(jobId, 0);\n\n    // Avvia l'importazione in background (non aspettiamo il complete)\n    runAnagraficaImportJob(jobId, templateName, fileContent, req.file.originalname);\n\n    // Rispondi subito al client con l'ID del job\n    res.status(202).json({ jobId });\n});\n\n// Endpoint per RICEVERE gli aggiornamenti di stato via SSE\nrouter.get('/:templateName/status/:jobId', (req: Request, res: Response) => {\n    const { jobId } = req.params;\n\n    res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive',\n    });\n\n    const sendUpdate = (job: any) => {\n        if (job.id === jobId) {\n            res.write(`data: ${JSON.stringify(job)}\\n\\n`);\n        }\n    };\n\n    jobManager.on('update', sendUpdate);\n\n    // Se il client chiude la connessione, rimuovi il listener\n    req.on('close', () => {\n        jobManager.removeListener('update', sendUpdate);\n        res.end();\n    });\n\n    // Invia lo stato attuale al momento della connessione\n    const currentJob = jobManager.get(jobId);\n    if (currentJob) {\n        sendUpdate(currentJob);\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importAnagrafiche.ts.bak",
          "type": "file",
          "token_estimate": 2735,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient, Prisma, TipoConto } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\nrouter.post('/:templateName', upload.single('file'), async (req: Request, res: Response) => {\n    const { templateName } = req.params;\n\n    if (!req.file) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n    \n    const file = req.file;\n\n    try {\n        // 1. Recupera il template e le definizioni dal DB\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: templateName },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            return res.status(404).json({ error: `Template '${templateName}' non trovato.` });\n        }\n\n        const modelName = (importTemplate as any).modelName as keyof PrismaClient;\n        const fileContent = file.buffer.toString('utf-8');\n        const fieldDefinitions = importTemplate.fields.map(f => ({ name: f.nomeCampo, start: f.start, length: f.length, type: f.type as any }));\n        const parsedData = parseFixedWidth<any>(fileContent, fieldDefinitions);\n\n        // Gestione speciale per anagrafica clienti/fornitori\n        if (templateName === 'anagrafica_clifor') {\n            await prisma.$transaction(async (tx) => {\n                for (const record of parsedData) {\n                    const externalId = record.externalId?.trim();\n                    if (!externalId) {\n                        continue; // Salta record senza un ID esterno valido\n                    }\n\n                    const dataToUpsert = {\n                        id: externalId,\n                        externalId: externalId,\n                        nome: record.nome?.trim() || 'N/A',\n                        piva: record.piva?.trim(),\n                        codiceFiscale: record.codiceFiscale?.trim(),\n                    };\n\n                    const createInCliente = async () => {\n                        // Se la P.IVA è fornita, controlla che non esista già per un ID diverso\n                        if (dataToUpsert.piva) {\n                            const existing = await tx.cliente.findUnique({\n                                where: { piva: dataToUpsert.piva },\n                            });\n                            // Se esiste un cliente con questa P.IVA e ID diverso, salta per evitare conflitti\n                            if (existing && existing.id !== dataToUpsert.id) {\n                                console.warn(`Cliente con P.IVA ${dataToUpsert.piva} già esistente (ID: ${existing.id}). Record con ID ${dataToUpsert.id} saltato.`);\n                                return;\n                            }\n                        }\n                        await tx.cliente.upsert({\n                            where: { id: dataToUpsert.id },\n                            update: dataToUpsert,\n                            create: dataToUpsert,\n                        });\n                    };\n\n                    const createInFornitore = async () => {\n                        // Se la P.IVA è fornita, controlla che non esista già per un ID diverso\n                        if (dataToUpsert.piva) {\n                            const existing = await tx.fornitore.findUnique({\n                                where: { piva: dataToUpsert.piva },\n                            });\n                            // Se esiste un fornitore con questa P.IVA e ID diverso, salta per evitare conflitti\n                            if (existing && existing.id !== dataToUpsert.id) {\n                                console.warn(`Fornitore con P.IVA ${dataToUpsert.piva} già esistente (ID: ${existing.id}). Record con ID ${dataToUpsert.id} saltato.`);\n                                return;\n                            }\n                        }\n                        await tx.fornitore.upsert({\n                            where: { id: dataToUpsert.id },\n                            update: dataToUpsert,\n                            create: dataToUpsert,\n                        });\n                    };\n\n                    const tipoAnagrafica = record.tipo?.trim().toUpperCase();\n\n                    if (tipoAnagrafica === 'C') {\n                        await createInCliente();\n                    } else if (tipoAnagrafica === 'F') {\n                        await createInFornitore();\n                    } else if (tipoAnagrafica === 'E') {\n                        await createInCliente();\n                        await createInFornitore();\n                    }\n                }\n            });\n             return res.status(200).json({ message: `Importazione per '${templateName}' completata con successo.` });\n        }\n\n        // Gestione per Piano dei Conti (CONTIGEN.TXT)\n        if (templateName === 'piano_dei_conti') {\n            let processedCount = 0;\n            const batchSize = 100; // Processa in batch per evitare timeout\n            \n            try {\n                // Filtra e prepara i dati prima della transazione\n                const validRecords = parsedData\n                    .map(record => {\n                        const codice = record.codice?.trim();\n                        if (!codice) return null;\n\n                        // Mappa il tipo carattere a TipoConto enum\n                        let tipo: TipoConto;\n                        const tipoChar = record.tipoChar?.trim();\n                        switch (tipoChar) {\n                            case 'P': \n                                tipo = TipoConto.Patrimoniale; \n                                break;\n                            case 'E': \n                                // Per i conti economici, distingui tra ricavi (classe 1) e costi (altre classi)\n                                tipo = codice.startsWith('1') ? TipoConto.Ricavo : TipoConto.Costo; \n                                break;\n                            case 'C': \n                                tipo = TipoConto.Cliente; \n                                break;\n                            case 'F': \n                                tipo = TipoConto.Fornitore; \n                                break;\n                            default: \n                                tipo = TipoConto.Patrimoniale; \n                                break;\n                        }\n\n                        return {\n                            id: codice,\n                            externalId: codice,\n                            codice: codice,\n                            nome: record.nome?.trim() || 'Conto senza nome',\n                            tipo: tipo,\n                            richiedeVoceAnalitica: false,\n                            vociAnaliticheAbilitateIds: [],\n                            contropartiteSuggeriteIds: []\n                        };\n                    })\n                    .filter(record => record !== null);\n\n                console.log(`Piano dei conti: ${validRecords.length} record validi da processare`);\n\n                // Processa in batch\n                for (let i = 0; i < validRecords.length; i += batchSize) {\n                    const batch = validRecords.slice(i, i + batchSize);\n                    \n                    await prisma.$transaction(async (tx) => {\n                        for (const dataToUpsert of batch) {\n                            try {\n                                await tx.conto.upsert({\n                                    where: { id: dataToUpsert.id },\n                                    update: {\n                                        nome: dataToUpsert.nome,\n                                        tipo: dataToUpsert.tipo,\n                                        externalId: dataToUpsert.externalId,\n                                        richiedeVoceAnalitica: dataToUpsert.richiedeVoceAnalitica,\n                                        vociAnaliticheAbilitateIds: dataToUpsert.vociAnaliticheAbilitateIds,\n                                        contropartiteSuggeriteIds: dataToUpsert.contropartiteSuggeriteIds\n                                    },\n                                    create: dataToUpsert,\n                                });\n                                processedCount++;\n                            } catch (error) {\n                                console.warn(`Errore processando conto ${dataToUpsert.codice}:`, error);\n                            }\n                        }\n                    });\n                    \n                    console.log(`Piano dei conti: processati ${Math.min(i + batchSize, validRecords.length)}/${validRecords.length} record`);\n                }\n                \n                console.log(`✅ IMPORTAZIONE COMPLETATA: ${processedCount} conti salvati nel database su ${parsedData.length} record totali`);\n                \n                return res.status(200).json({ \n                    message: `Importazione piano dei conti completata. ${processedCount} conti processati su ${parsedData.length} record totali.` \n                });\n            } catch (error) {\n                console.error('Errore durante importazione piano dei conti:', error);\n                return res.status(500).json({ \n                    error: `Errore durante importazione piano dei conti: ${(error as Error).message}. Processati: ${processedCount} record.` \n                });\n            }\n        }\n\n        if (!modelName || !(prisma as any)[modelName]) {\n            return res.status(400).json({ error: `Il nome del modello per '${templateName}' non è valido o non è configurato.` });\n        }\n\n        // Esegui il parsing e il salvataggio per anagrafiche generiche\n        await prisma.$transaction(async (tx) => {\n            for (const record of parsedData) {\n                const dataToUpsert = { ...record };\n                Object.keys(dataToUpsert).forEach(key => {\n                    if (typeof dataToUpsert[key] === 'string') {\n                        dataToUpsert[key] = dataToUpsert[key].trim();\n                    }\n                });\n\n                if (!dataToUpsert.id) continue;\n\n                await (tx as any)[modelName].upsert({\n                    where: { id: dataToUpsert.id },\n                    update: dataToUpsert,\n                    create: dataToUpsert,\n                });\n            }\n        });\n\n        return res.status(200).json({ message: `Importazione per '${templateName}' completata. ${parsedData.length} record processati.` });\n\n    } catch (error: any) {\n        console.error(`Errore durante l'importazione per '${templateName}':`, error);\n        res.status(500).json({ error: \"Errore interno del server durante l'importazione.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importScritture.ts",
          "type": "file",
          "token_estimate": 1242,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\nimport { processScrittureInBatches } from '../lib/importUtils.js';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\nrouter.post('/', upload.array('files', 10), async (req: Request, res: Response) => {\n    if (!req.files || (req.files as Express.Multer.File[]).length === 0) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n    \n    const files = req.files as Express.Multer.File[];\n    let rowCount = 0;\n    let status = \"FAILED\";\n    let errorMessage: string | null = null;\n    const fileNames = files.map(f => f.originalname).join(', ');\n\n    try {\n        // 1. Recupera il template e le definizioni dal DB\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: 'scritture_contabili' },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            return res.status(404).json({ error: \"Template 'scritture_contabili' non trovato.\" });\n        }\n        \n        // 2. Raggruppa le definizioni per fileIdentifier\n        const definitionsByFile = importTemplate.fields.reduce((acc, field) => {\n            const key = (field as any).fileIdentifier || 'default';\n            if (!acc[key]) {\n                acc[key] = [];\n            }\n            acc[key].push({\n                name: field.nomeCampo,\n                start: field.start,\n                length: field.length,\n                type: field.type as 'string' | 'number' | 'date',\n            });\n            return acc;\n        }, {} as Record<string, FieldDefinition[]>);\n\n        // 3. Associa i file caricati alle loro definizioni\n        const filesByDefinition = Object.keys(definitionsByFile).reduce((acc, key) => {\n            const file = files.find(f => f.originalname === key);\n            if (file) {\n                acc[key] = {\n                    file,\n                    definitions: definitionsByFile[key]\n                };\n            }\n            return acc;\n        }, {} as Record<string, { file: Express.Multer.File, definitions: FieldDefinition[] }>);\n\n        console.log('File trovati e associati:', Object.keys(filesByDefinition));\n\n        // VERIFICA: Assicurarsi che tutti i file necessari siano presenti\n        const requiredFiles = ['PNTESTA.TXT', 'PNRIGCON.TXT']; // PNRIGANA.TXT è opzionale\n        for (const requiredFile of requiredFiles) {\n            if (!filesByDefinition[requiredFile]) {\n                return res.status(400).json({ error: `File mancante: ${requiredFile} è richiesto per questa importazione.` });\n            }\n        }\n\n        // 4. Esegui il parsing per ogni file\n        const testate = parseFixedWidth<any>(filesByDefinition['PNTESTA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNTESTA.TXT'].definitions);\n        const righeContabili = parseFixedWidth<any>(filesByDefinition['PNRIGCON.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGCON.TXT'].definitions);\n        \n        let righeIva: any[] = [];\n        if (filesByDefinition['PNRIGIVA.TXT']) {\n            righeIva = parseFixedWidth<any>(filesByDefinition['PNRIGIVA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGIVA.TXT'].definitions);\n        }\n\n        let allocazioni: any[] = [];\n        if (filesByDefinition['MOVANAC.TXT']) {\n            allocazioni = parseFixedWidth<any>(filesByDefinition['MOVANAC.TXT'].file.buffer.toString('utf-8'), filesByDefinition['MOVANAC.TXT'].definitions);\n        }\n\n        // 5. Salva i dati in una transazione\n        const summary = await processScrittureInBatches({ testate, righeContabili, righeIva, allocazioni });\n        \n        rowCount = summary.processedCount;\n        if (summary.errorCount > 0) {\n            status = \"PARTIAL_SUCCESS\";\n            errorMessage = `${summary.errorCount} record non sono stati importati correttamente. Controllare i log del server.`;\n        } else {\n            status = \"SUCCESS\";\n        }\n\n        return res.status(200).json({ \n            message: `Importazione completata. ${summary.processedCount} record processati, ${summary.errorCount} errori.`,\n            summary\n        });\n\n    } catch (error: any) {\n        console.error(\"Errore durante l'importazione delle scritture:\", error);\n        errorMessage = error.message;\n        res.status(500).json({ error: \"Errore interno del server durante l'importazione.\" });\n    } finally {\n        await prisma.importLog.create({\n            data: {\n                fileName: fileNames,\n                templateName: 'scritture_contabili',\n                rowCount: rowCount,\n                status: status,\n                error: errorMessage,\n            }\n        });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importScritture.ts.bak",
          "type": "file",
          "token_estimate": 1039,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\nimport { processScrittureInBatches } from '../lib/importUtils.js';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\nrouter.post('/', upload.array('files', 10), async (req: Request, res: Response) => {\n    if (!req.files || (req.files as Express.Multer.File[]).length === 0) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n    \n    const files = req.files as Express.Multer.File[];\n\n    try {\n        // 1. Recupera il template e le definizioni dal DB\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: 'scritture_contabili' },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            return res.status(404).json({ error: \"Template 'scritture_contabili' non trovato.\" });\n        }\n        \n        // 2. Raggruppa le definizioni per fileIdentifier\n        const definitionsByFile = importTemplate.fields.reduce((acc, field) => {\n            const key = (field as any).fileIdentifier || 'default';\n            if (!acc[key]) {\n                acc[key] = [];\n            }\n            acc[key].push({\n                name: field.nomeCampo,\n                start: field.start,\n                length: field.length,\n                type: field.type as 'string' | 'number' | 'date',\n            });\n            return acc;\n        }, {} as Record<string, FieldDefinition[]>);\n\n        // 3. Associa i file caricati alle loro definizioni\n        const filesByDefinition = Object.keys(definitionsByFile).reduce((acc, key) => {\n            const file = files.find(f => f.originalname === key);\n            if (file) {\n                acc[key] = {\n                    file,\n                    definitions: definitionsByFile[key]\n                };\n            }\n            return acc;\n        }, {} as Record<string, { file: Express.Multer.File, definitions: FieldDefinition[] }>);\n\n        console.log('File trovati e associati:', Object.keys(filesByDefinition));\n\n        // VERIFICA: Assicurarsi che tutti i file necessari siano presenti\n        const requiredFiles = ['PNTESTA.TXT', 'PNRIGCON.TXT']; // PNRIGANA.TXT è opzionale\n        for (const requiredFile of requiredFiles) {\n            if (!filesByDefinition[requiredFile]) {\n                return res.status(400).json({ error: `File mancante: ${requiredFile} è richiesto per questa importazione.` });\n            }\n        }\n\n        // 4. Esegui il parsing per ogni file\n        const testate = parseFixedWidth<any>(filesByDefinition['PNTESTA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNTESTA.TXT'].definitions);\n        const righeContabili = parseFixedWidth<any>(filesByDefinition['PNRIGCON.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGCON.TXT'].definitions);\n        \n        let righeIva: any[] = [];\n        if (filesByDefinition['PNRIGIVA.TXT']) {\n            righeIva = parseFixedWidth<any>(filesByDefinition['PNRIGIVA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGIVA.TXT'].definitions);\n        }\n\n        let allocazioni: any[] = [];\n        if (filesByDefinition['MOVANAC.TXT']) {\n            allocazioni = parseFixedWidth<any>(filesByDefinition['MOVANAC.TXT'].file.buffer.toString('utf-8'), filesByDefinition['MOVANAC.TXT'].definitions);\n        }\n\n        // 5. Salva i dati in una transazione\n        const summary = await processScrittureInBatches({ testate, righeContabili, righeIva, allocazioni });\n\n        return res.status(200).json({ \n            message: `Importazione completata. ${summary.processedCount} record processati, ${summary.errorCount} errori.`,\n            summary\n        });\n\n    } catch (error: any) {\n        console.error(\"Errore durante l'importazione delle scritture:\", error);\n        res.status(500).json({ error: \"Errore interno del server durante l'importazione.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importTemplates.ts",
          "type": "file",
          "token_estimate": 1538,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET all import templates\nrouter.get('/', async (req, res) => {\n    try {\n        const { \n            page = '1', \n            limit = '25', \n            search = '',\n            sortBy = 'nome',\n            sortOrder = 'asc'\n        } = req.query;\n\n        const pageNumber = parseInt(page as string, 10);\n        const pageSize = parseInt(limit as string, 10);\n        const skip = (pageNumber - 1) * pageSize;\n        const take = pageSize;\n\n        const where: Prisma.ImportTemplateWhereInput = search ? {\n            OR: [\n                { nome: { contains: search as string, mode: 'insensitive' } },\n            ],\n        } : {};\n\n        const orderBy: Prisma.ImportTemplateOrderByWithRelationInput = {\n            [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n        };\n\n        const [templates, totalCount] = await prisma.$transaction([\n            prisma.importTemplate.findMany({\n                where,\n                orderBy,\n                skip,\n                take,\n                include: { fields: true },\n            }),\n            prisma.importTemplate.count({ where }),\n        ]);\n        \n        res.json({\n            data: templates,\n            pagination: {\n                page: pageNumber,\n                limit: pageSize,\n                total: totalCount,\n                totalPages: Math.ceil(totalCount / pageSize),\n            }\n        });\n    } catch (error) {\n        console.error(\"Errore nel recupero dei template di importazione:\", error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// POST a new import template\nrouter.post('/', async (req, res) => {\n    const { nome, fields } = req.body;\n\n    if (!nome || !fields) {\n        return res.status(400).json({ error: \"Il nome e i campi del template sono obbligatori.\" });\n    }\n\n    try {\n        const newTemplate = await prisma.importTemplate.create({\n            data: {\n                nome,\n                fields: {\n                    create: fields.map((field: any) => ({\n                        nomeCampo: field.nomeCampo,\n                        start: parseInt(field.start, 10),\n                        length: parseInt(field.length, 10),\n                        type: field.type,\n                        fileIdentifier: field.fileIdentifier || null\n                    } as any))\n                }\n            },\n            include: { fields: true }\n        });\n        res.status(201).json(newTemplate);\n    } catch (error) {\n        console.error(\"Errore nella creazione del template:\", error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// PUT (update) an import template\nrouter.put('/:id', async (req, res) => {\n    const { id } = req.params;\n    const { nome, fields } = req.body;\n\n    if (!nome || !fields) {\n        return res.status(400).json({ error: \"Il nome e i campi del template sono obbligatori.\" });\n    }\n\n    try {\n        const updatedTemplate = await prisma.$transaction(async (tx) => {\n            // 1. Aggiorna il nome del template\n            const template = await tx.importTemplate.update({\n                where: { id },\n                data: { nome }\n            });\n\n            const existingFields = await tx.fieldDefinition.findMany({ where: { templateId: id } });\n            const existingFieldIds = new Set(existingFields.map(f => f.id));\n            const incomingFieldIds = new Set(fields.map((f: any) => f.id).filter(Boolean));\n\n            // 2. Identifica i campi da eliminare\n            const fieldsToDelete = [...existingFieldIds].filter(fieldId => !incomingFieldIds.has(fieldId));\n            if (fieldsToDelete.length > 0) {\n                await tx.fieldDefinition.deleteMany({\n                    where: { id: { in: fieldsToDelete } }\n                });\n            }\n\n            // 3. Aggiorna o crea i campi\n            for (const field of fields) {\n                if (field.id && existingFieldIds.has(field.id)) {\n                    // Aggiorna campo esistente\n                    await tx.fieldDefinition.update({\n                        where: { id: field.id },\n                        data: {\n                            nomeCampo: field.nomeCampo,\n                            start: parseInt(field.start, 10),\n                            length: parseInt(field.length, 10),\n                            type: field.type,\n                            fileIdentifier: field.fileIdentifier || null\n                        } as any\n                    });\n                } else {\n                    // Crea nuovo campo\n                    await tx.fieldDefinition.create({\n                        data: {\n                            templateId: id,\n                            nomeCampo: field.nomeCampo,\n                            start: parseInt(field.start, 10),\n                            length: parseInt(field.length, 10),\n                            type: field.type,\n                            fileIdentifier: field.fileIdentifier || null\n                        } as any\n                    });\n                }\n            }\n\n            return tx.importTemplate.findUnique({\n                where: { id },\n                include: { fields: true }\n            });\n        });\n\n        res.json(updatedTemplate);\n\n    } catch (error) {\n        console.error(`Errore nell'aggiornamento del template ${id}:`, error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// DELETE an import template\nrouter.delete('/:id', async (req, res) => {\n    const { id } = req.params;\n    try {\n        // La cancellazione a cascata è gestita da Prisma in base allo schema\n        await prisma.importTemplate.delete({\n            where: { id }\n        });\n        res.status(204).send();\n    } catch (error) {\n        console.error(`Errore nella cancellazione del template ${id}:`, error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "registrazioni.ts",
          "type": "file",
          "token_estimate": 1357,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\n// Tipi incollati per evitare errore rootDir\ninterface ScritturaContabile {\n  id: string;\n  data: string; \n  causaleId: string;\n  descrizione: string;\n  righe: RigaScrittura[];\n  datiAggiuntivi?: {\n    fornitoreId?: string | null;\n    clienteId?: string | null;\n    totaleFattura?: number | string;\n    aliquotaIva?: number;\n  };\n}\n\ninterface RigaScrittura {\n  id: string;\n  descrizione: string;\n  dare: number;\n  avere: number;\n  contoId: string;\n  allocazioni: Allocazione[];\n}\n\ninterface Allocazione {\n  id: string;\n  commessaId: string;\n  voceAnaliticaId: string;\n  importo: number;\n  descrizione?: string;\n}\n\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET all with pagination, search, and sort\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n      page = '1', \n      limit = '25', \n      search = '',\n      sortBy = 'data',\n      sortOrder = 'desc',\n      dateFrom = '',\n      dateTo = ''\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.ScritturaContabileWhereInput = {\n      ...(search && {\n        descrizione: { contains: search as string, mode: 'insensitive' }\n      }),\n      ...(dateFrom && dateTo && {\n        data: {\n          gte: new Date(dateFrom as string),\n          lte: new Date(dateTo as string)\n        }\n      })\n    };\n\n    const orderBy: Prisma.ScritturaContabileOrderByWithRelationInput = {\n        [(sortBy as string) || 'data']: (sortOrder as 'asc' | 'desc') || 'desc'\n    };\n\n    const [scritture, totalCount] = await prisma.$transaction([\n      prisma.scritturaContabile.findMany({\n        where,\n        orderBy,\n        skip,\n        take,\n        include: { \n          righe: { include: { conto: true, allocazioni: true } },\n          fornitore: true\n        },\n      }),\n      prisma.scritturaContabile.count({ where }),\n    ]);\n\n    res.json({\n      data: scritture,\n      pagination: {\n        page: pageNumber,\n        limit: pageSize,\n        total: totalCount,\n        totalPages: Math.ceil(totalCount / pageSize),\n      }\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Errore nel caricamento delle scritture' });\n  }\n});\n\n// GET by ID\nrouter.get('/:id', async (req, res) => {\n    try {\n        const scrittura = await prisma.scritturaContabile.findUnique({\n            where: { id: req.params.id },\n            include: { righe: { include: { conto: true, allocazioni: true } } },\n        });\n        if (!scrittura) return res.status(404).json({ error: 'Scrittura non trovata' });\n        res.json(scrittura);\n    } catch (error) {\n        res.status(500).json({ error: 'Errore nel caricamento della scrittura' });\n    }\n});\n\n\n// POST (Create)\nrouter.post('/', async (req, res) => {\n    const { righe, ...data } = req.body as ScritturaContabile;\n    try {\n        const nuovaScrittura = await prisma.scritturaContabile.create({\n            data: {\n                ...data,\n                data: new Date(data.data),\n                righe: {\n                    create: righe.map(riga => ({\n                        ...riga,\n                        allocazioni: {\n                            create: riga.allocazioni || [],\n                        }\n                    }))\n                }\n            },\n            include: { righe: true }\n        });\n        res.status(201).json(nuovaScrittura);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Errore nella creazione della scrittura' });\n    }\n});\n\n// PUT (Update)\nrouter.put('/:id', async (req, res) => {\n    const { id } = req.params;\n    const { righe, ...data } = req.body as ScritturaContabile;\n    try {\n        // Transazione per aggiornare: cancella le vecchie righe e crea le nuove\n        const updatedScrittura = await prisma.$transaction(async (tx) => {\n            await tx.rigaScrittura.deleteMany({ where: { scritturaContabileId: id }});\n            \n            return tx.scritturaContabile.update({\n                where: { id },\n                data: {\n                    ...data,\n                    data: new Date(data.data),\n                    righe: {\n                        create: righe.map(riga => ({\n                            descrizione: riga.descrizione,\n                            dare: riga.dare,\n                            avere: riga.avere,\n                            contoId: riga.contoId,\n                            allocazioni: {\n                                create: riga.allocazioni || [],\n                            }\n                        }))\n                    }\n                },\n                 include: { righe: { include: { allocazioni: true }}}\n            });\n        });\n        res.json(updatedScrittura);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Errore nell\\'aggiornamento della scrittura' });\n    }\n});\n\n\n// DELETE\nrouter.delete('/:id', async (req, res) => {\n    try {\n        await prisma.scritturaContabile.delete({ where: { id: req.params.id } });\n        res.status(204).send();\n    } catch (error) {\n        res.status(500).json({ error: 'Errore nell\\'eliminazione della scrittura' });\n    }\n});\n\n\nexport default router; "
        },
        {
          "name": "system.ts",
          "type": "file",
          "token_estimate": 856,
          "content": "import { Router } from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = Router();\nconst prisma = new PrismaClient();\n\nrouter.get('/status', async (c, res) => {\n  try {\n    const [\n      contiCount,\n      clientiCount,\n      fornitoriCount,\n      causaliCount,\n      codiciIvaCount,\n      condizioniPagamentoCount,\n      commesseCount,\n      scrittureCount,\n    ] = await prisma.$transaction([\n      prisma.conto.count(),\n      prisma.cliente.count(),\n      prisma.fornitore.count(),\n      prisma.causaleContabile.count(),\n      prisma.codiceIva.count(),\n      prisma.condizionePagamento.count(),\n      prisma.commessa.count(),\n      prisma.scritturaContabile.count(),\n    ]);\n\n    // Recupera i wizard steps usando query raw (client Prisma non ancora aggiornato)\n    const wizardSteps = await prisma.$queryRaw<Array<{\n      stepId: string;\n      stepTitle: string;\n      templateName: string;\n      status: string;\n      fileName?: string;\n      recordCount?: number;\n      completedAt?: Date;\n      error?: string;\n    }>>`SELECT * FROM \"WizardStep\"`;\n\n    // Crea una mappa degli step del wizard per accesso rapido\n    const wizardStepsMap = wizardSteps.reduce((acc, step) => {\n      acc[step.stepId] = step;\n      return acc;\n    }, {} as Record<string, any>);\n\n    const anagraficheDiBasePopolate =\n      contiCount > 0 && clientiCount > 0 && fornitoriCount > 0 && causaliCount > 0;\n\n    const needsInitialization = !anagraficheDiBasePopolate;\n\n    return res.json({\n      needsInitialization,\n      status: needsInitialization ? 'incomplete' : 'ready',\n      checks: {\n        conti: { \n          count: contiCount, \n          status: contiCount > 0 ? 'ok' : 'missing',\n          wizardStep: wizardStepsMap['conti'] || null\n        },\n        clienti: { \n          count: clientiCount, \n          status: clientiCount > 0 ? 'ok' : 'missing',\n          wizardStep: wizardStepsMap['clienti'] || null\n        },\n        fornitori: { count: fornitoriCount, status: fornitoriCount > 0 ? 'ok' : 'missing' },\n        causali: { \n          count: causaliCount, \n          status: causaliCount > 0 ? 'ok' : 'missing',\n          wizardStep: wizardStepsMap['causali'] || null\n        },\n        codiciIva: { count: codiciIvaCount, status: 'ok' },\n        condizioniPagamento: { count: condizioniPagamentoCount, status: 'ok' },\n        commesse: { count: commesseCount, status: 'ok' },\n        scritture: { count: scrittureCount, status: 'ok' },\n      },\n      wizardSteps: wizardStepsMap,\n    });\n  } catch (error) {\n    console.error(\"Failed to get system status:\", error);\n    return res.status(500).json({ error: 'Failed to retrieve system status' });\n  }\n});\n\n// Nuovo endpoint per recuperare i dettagli degli import logs\nrouter.get('/import-logs/:templateName?', async (req, res) => {\n  try {\n    // Per ora restituiamo dati mock finché non risolviamo il client Prisma\n    const mockData = {\n      logs: [],\n      stats: {\n        'piano_dei_conti': { total: 1, success: 1, failed: 0, totalRows: 150 },\n        'anagrafica_clifor': { total: 1, success: 1, failed: 0, totalRows: 320 },\n        'causali': { total: 0, success: 0, failed: 0, totalRows: 0 }\n      }\n    };\n    \n    return res.json(mockData);\n  } catch (error) {\n    console.error(\"Failed to get import logs:\", error);\n    return res.status(500).json({ error: 'Failed to retrieve import logs' });\n  }\n});\n\nexport const system = router; "
        },
        {
          "name": "vociAnalitiche.ts",
          "type": "file",
          "token_estimate": 671,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all voci analitiche\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n        page = '1', \n        limit = '25', \n        search = '',\n        sortBy = 'nome',\n        sortOrder = 'asc'\n    } = req.query;\n\n    const pageNumber = parseInt(page as string, 10);\n    const pageSize = parseInt(limit as string, 10);\n    const skip = (pageNumber - 1) * pageSize;\n    const take = pageSize;\n\n    const where: Prisma.VoceAnaliticaWhereInput = search ? {\n        OR: [\n            { id: { contains: search as string, mode: 'insensitive' } },\n            { nome: { contains: search as string, mode: 'insensitive' } },\n            { descrizione: { contains: search as string, mode: 'insensitive' } },\n        ],\n    } : {};\n\n    const orderBy: Prisma.VoceAnaliticaOrderByWithRelationInput = {\n        [(sortBy as string) || 'nome']: (sortOrder as 'asc' | 'desc') || 'asc'\n    };\n\n    const [vociAnalitiche, totalCount] = await prisma.$transaction([\n        prisma.voceAnalitica.findMany({\n            where,\n            orderBy,\n            skip,\n            take,\n        }),\n        prisma.voceAnalitica.count({ where }),\n    ]);\n\n    res.json({\n        data: vociAnalitiche,\n        pagination: {\n            page: pageNumber,\n            limit: pageSize,\n            total: totalCount,\n            totalPages: Math.ceil(totalCount / pageSize),\n        }\n    });\n\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel recupero delle voci analitiche.' });\n  }\n});\n\n// POST a new voce analitica\nrouter.post('/', async (req, res) => {\n  try {\n    const nuovaVoce = await prisma.voceAnalitica.create({\n      data: req.body,\n    });\n    res.status(201).json(nuovaVoce);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nella creazione della voce analitica.' });\n  }\n});\n\n// PUT update a voce analitica\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const voceAggiornata = await prisma.voceAnalitica.update({\n      where: { id },\n      data: req.body,\n    });\n    res.json(voceAggiornata);\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'aggiornamento della voce analitica ${id}.` });\n  }\n});\n\n// DELETE a voce analitica\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    await prisma.voceAnalitica.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione della voce analitica ${id}.` });\n  }\n});\n\nexport default router; "
        }
      ]
    },
    {
      "name": "tsconfig.json",
      "type": "file",
      "token_estimate": 203,
      "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": false,\n    \"removeComments\": true,\n    \"noImplicitAny\": false,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitThis\": true,\n    \"noImplicitReturns\": false,\n    \"noFallthroughCasesInSwitch\": true,\n    \"moduleResolution\": \"node\",\n    \"allowJs\": true,\n    \"checkJs\": false,\n    \"isolatedModules\": true\n  },\n  \"ts-node\": {\n    \"esm\": true\n  },\n  \"include\": [\n    \"**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\"\n  ]\n} "
    }
  ]
}