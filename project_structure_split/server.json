{
  "name": "server",
  "type": "directory",
  "total_token_estimate": 13704,
  "children": [
    {
      "name": ".eslintrc.json",
      "type": "file",
      "token_estimate": 146,
      "content": "{\n  \"extends\": [\n    \"@typescript-eslint/recommended\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 2020,\n    \"sourceType\": \"module\",\n    \"project\": \"./tsconfig.json\"\n  },\n  \"rules\": {\n    \"@typescript-eslint/no-require-imports\": \"off\",\n    \"@typescript-eslint/no-explicit-any\": \"off\",\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n    \"@typescript-eslint/no-unused-vars\": [\"error\", { \"argsIgnorePattern\": \"^_\" }],\n    \"@typescript-eslint/no-implicit-any-catch\": \"off\"\n  },\n  \"env\": {\n    \"node\": true,\n    \"es6\": true\n  }\n} "
    },
    {
      "name": "index.ts",
      "type": "file",
      "token_estimate": 615,
      "content": "import 'dotenv/config'; // Carica le variabili d'ambiente\nimport express, { Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport { PrismaClient } from '@prisma/client';\n\n// Importa le rotte\nimport clientiRoutes from './routes/clienti';\nimport fornitoriRoutes from './routes/fornitori';\nimport registrazioniRoutes from './routes/registrazioni';\nimport dashboardRoutes from './routes/dashboard';\nimport databaseRoutes from './routes/database';\nimport importScrittureRoutes from './routes/importScritture';\nimport importAnagraficheRoutes from './routes/importAnagrafiche';\nimport causaliRoutes from './routes/causali';\nimport vociAnaliticheRoutes from './routes/vociAnalitiche';\nimport contiRoutes from './routes/conti';\nimport commesseRoutes from './routes/commesse';\nimport importTemplatesRoutes from './routes/importTemplates';\nimport codiciIvaRoutes from './routes/codiciIva';\nimport condizioniPagamentoRoutes from './routes/condizioniPagamento';\n\nconst app = express();\nconst prisma = new PrismaClient();\nconst PORT = process.env.PORT || 3001;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.static('public'));\n\n// Registra le rotte\napp.use('/api/clienti', clientiRoutes);\napp.use('/api/fornitori', fornitoriRoutes);\napp.use('/api/registrazioni', registrazioniRoutes);\napp.use('/api/dashboard', dashboardRoutes);\napp.use('/api/database', databaseRoutes);\napp.use('/api/import/scritture', importScrittureRoutes);\napp.use('/api/import/anagrafica', importAnagraficheRoutes);\napp.use('/api/causali', causaliRoutes);\napp.use('/api/voci-analitiche', vociAnaliticheRoutes);\napp.use('/api/conti', contiRoutes);\napp.use('/api/commesse', commesseRoutes);\napp.use('/api/import-templates', importTemplatesRoutes);\napp.use('/api/codici-iva', codiciIvaRoutes);\napp.use('/api/condizioni-pagamento', condizioniPagamentoRoutes);\n\n\n// Endpoint di base per testare il server\napp.get('/api', (req: Request, res: Response) => {\n  res.json({ message: 'Commessa Control Hub API' });\n});\n\n// Gestione errori globale (esempio base)\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  console.error(err.stack);\n  res.status(500).send('Qualcosa Ã¨ andato storto!');\n});\n\n// Avvia il server\napp.listen(PORT, () => {\n  console.log(`Server in esecuzione sulla porta ${PORT}`);\n});\n\n// Gestione della chiusura del processo\nprocess.on('SIGINT', async () => {\n  await prisma.$disconnect();\n  process.exit(0);\n}); "
    },
    {
      "name": "lib",
      "type": "directory",
      "children": [
        {
          "name": "fixedWidthParser.ts",
          "type": "file",
          "token_estimate": 446,
          "content": "/**\n * Definizione di un campo per il parser a larghezza fissa.\n */\nexport interface FieldDefinition {\n  name: string;\n  start: number;\n  length: number;\n  type?: 'string' | 'number' | 'date';\n}\n\n/**\n * Esegue il parsing di una stringa di testo a larghezza fissa.\n */\nexport function parseFixedWidth<T>(\n  content: string,\n  definitions: FieldDefinition[]\n): T[] {\n  const lines = content.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n  const results: T[] = [];\n\n  for (const line of lines) {\n    const parsedObject: { [key: string]: any } = {};\n\n    for (const def of definitions) {\n      const rawValue = line.substring(def.start, def.start + def.length).trim();\n      \n      switch (def.type) {\n        case 'number':\n          parsedObject[def.name] = parseFloat(rawValue.trim().replace(',', '.')) || 0;\n          break;\n        case 'date':\n          // Formato atteso: DDMMYYYY. Gestisce stringhe vuote o non valide.\n          const dateStr = rawValue.trim();\n          if (dateStr && dateStr.length === 8) {\n            const day = parseInt(dateStr.substring(0, 2), 10);\n            const month = parseInt(dateStr.substring(2, 4), 10);\n            const year = parseInt(dateStr.substring(4, 8), 10);\n            \n            if (!isNaN(day) && !isNaN(month) && !isNaN(year) && year > 1900 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {\n              parsedObject[def.name] = new Date(year, month - 1, day);\n            } else {\n              parsedObject[def.name] = null;\n            }\n          } else {\n            parsedObject[def.name] = null;\n          }\n          break;\n        case 'string':\n        default:\n          parsedObject[def.name] = rawValue;\n          break;\n      }\n    }\n    results.push(parsedObject as T);\n  }\n\n  return results;\n} "
        },
        {
          "name": "importUtils.ts",
          "type": "file",
          "token_estimate": 1870,
          "content": "import { Prisma, PrismaClient, TipoConto } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst SYSTEM_CUSTOMER_ID = 'system_customer_01'; // Assicurati che questo ID sia nel seed\nconst SYSTEM_SUPPLIER_ID = 'system_supplier_01';\n\nexport async function processScrittureInBatches(data: { testate: any[], righeContabili: any[], righeIva: any[], allocazioni: any[] }) {\n    const { testate, righeContabili, righeIva, allocazioni } = data;\n    \n    // Mappe dati pre-elaborate per efficienza\n    const testateMap = new Map(testate.map(t => [t.externalId.trim(), t]));\n    const righeContabiliMap = new Map<string, any[]>();\n    righeContabili.forEach(r => {\n        const testataId = r.externalId.substring(0, 12).trim();\n        if (!righeContabiliMap.has(testataId)) righeContabiliMap.set(testataId, []);\n        righeContabiliMap.get(testataId)!.push(r);\n    });\n    const righeIvaMap = new Map<string, any[]>();\n    righeIva.forEach(r => {\n        const rigaId = r.externalId.trim();\n        if (!righeIvaMap.has(rigaId)) righeIvaMap.set(rigaId, []);\n        righeIvaMap.get(rigaId)!.push(r);\n    });\n    const allocazioniMap = new Map<string, any[]>();\n    allocazioni.forEach(a => {\n        const rigaId = a.externalId.trim();\n        if (!allocazioniMap.has(rigaId)) allocazioniMap.set(rigaId, []);\n        allocazioniMap.get(rigaId)!.push(a);\n    });\n\n    let processedCount = 0;\n    let errorCount = 0;\n    const totalBatches = testateMap.size;\n    console.log(`[Import] Inizio elaborazione di ${totalBatches} scritture in batch...`);\n\n    for (const [testataId, testata] of testateMap.entries()) {\n        try {\n            // Ogni testata viene processata in una transazione separata\n            await prisma.$transaction(async (tx) => {\n                const fornitoreId = testata.clienteFornitoreCodiceFiscale?.trim();\n                if (fornitoreId) {\n                    await tx.fornitore.upsert({\n                        where: { id: fornitoreId },\n                        update: {},\n                        create: {\n                            id: fornitoreId,\n                            externalId: fornitoreId,\n                            nome: `Fornitore importato - ${fornitoreId}`\n                        }\n                    });\n                }\n\n                const scritturaData = {\n                    data: testata.dataRegistrazione,\n                    descrizione: `Importazione - ${testataId}`,\n                    causaleId: testata.causaleId.trim(),\n                    dataDocumento: testata.dataDocumento,\n                    numeroDocumento: testata.numeroDocumento.trim(),\n                    fornitoreId: fornitoreId || undefined\n                };\n\n                const scrittura = await tx.scritturaContabile.upsert({\n                    where: { externalId: testataId },\n                    update: scritturaData,\n                    create: { ...scritturaData, externalId: testataId }\n                });\n\n                const righeContabiliPerTestata = righeContabiliMap.get(testataId) || [];\n                for (const riga of righeContabiliPerTestata) {\n                    const rigaId = riga.externalId.trim();\n                    const contoId = riga.conto.trim();\n                    if (!contoId) continue;\n\n                    await tx.conto.upsert({\n                        where: { id: contoId },\n                        update: {},\n                        create: {\n                            id: contoId,\n                            codice: contoId,\n                            nome: `Conto importato - ${contoId}`,\n                            tipo: TipoConto.Patrimoniale,\n                            richiedeVoceAnalitica: false,\n                        }\n                    });\n\n                    const rigaScrittura = await tx.rigaScrittura.create({\n                        data: {\n                            scritturaContabileId: scrittura.id,\n                            descrizione: riga.note.trim(),\n                            dare: riga.importoDare,\n                            avere: riga.importoAvere,\n                            contoId: contoId,\n                        }\n                    });\n\n                    const righeIvaPerRiga = righeIvaMap.get(rigaId) || [];\n                    for (const rigaIva of righeIvaPerRiga) {\n                        const codiceIvaId = rigaIva.codiceIva.trim();\n                        if (!codiceIvaId) continue;\n                        await tx.codiceIva.upsert({\n                            where: { id: codiceIvaId },\n                            update: {},\n                            create: {\n                                id: codiceIvaId,\n                                descrizione: `IVA importata - ${codiceIvaId}`,\n                                aliquota: 0,\n                            }\n                        });\n                        await tx.rigaIva.create({\n                            data: {\n                                rigaScritturaId: rigaScrittura.id,\n                                imponibile: rigaIva.imponibile,\n                                imposta: rigaIva.imposta,\n                                codiceIvaId: codiceIvaId,\n                            }\n                        });\n                    }\n\n                    const allocazioniPerRiga = allocazioniMap.get(rigaId) || [];\n                    for (const alloc of allocazioniPerRiga) {\n                        const commessaId = alloc.centroDiCosto.trim();\n                        const voceAnaliticaId = alloc.parametro.toString().trim();\n                        if (!commessaId || !voceAnaliticaId) continue;\n\n                        await tx.voceAnalitica.upsert({\n                            where: { id: voceAnaliticaId },\n                            update: {},\n                            create: {\n                                id: voceAnaliticaId,\n                                nome: `Voce importata - ${voceAnaliticaId}`\n                            }\n                        });\n\n                        await tx.commessa.upsert({\n                            where: { id: commessaId },\n                            update: {},\n                            create: {\n                                id: commessaId,\n                                nome: `Commessa importata - ${commessaId}`,\n                                clienteId: SYSTEM_CUSTOMER_ID\n                            }\n                        });\n\n                        await tx.allocazione.create({\n                            data: {\n                                rigaScritturaId: rigaScrittura.id,\n                                importo: alloc.parametro,\n                                commessaId: commessaId,\n                                voceAnaliticaId: voceAnaliticaId, \n                            }\n                        });\n                    }\n                }\n            });\n            processedCount++;\n            if (processedCount % 100 === 0) {\n                console.log(`[Import] Progresso: ${processedCount} / ${totalBatches} scritture elaborate...`);\n            }\n        } catch (error) {\n            console.error(`[Import] Errore durante l'elaborazione della testata ${testataId}. Questo record sarÃ  saltato. Dettagli:`, error);\n            errorCount++;\n        }\n    }\n\n    console.log(`[Import] Elaborazione batch completata. Successo: ${processedCount}, Errori: ${errorCount}.`);\n    return { processedCount, errorCount };\n} "
        }
      ]
    },
    {
      "name": "routes",
      "type": "directory",
      "children": [
        {
          "name": "causali.ts",
          "type": "file",
          "token_estimate": 553,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutte le causali contabili\nrouter.get('/', async (req, res) => {\n  try {\n    const causali = await prisma.causaleContabile.findMany({\n        include: {\n            datiPrimari: true,\n            templateScrittura: true,\n        },\n        orderBy: {\n            nome: 'asc'\n        }\n    });\n    res.json(causali);\n  } catch (error) {\n    console.error('Errore nel caricamento delle causali contabili:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea una nuova causale contabile\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, nome, descrizione, externalId } = req.body;\n    \n    const causale = await prisma.causaleContabile.create({\n      data: {\n        id,\n        nome,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(causale);\n  } catch (error) {\n    console.error('Errore nella creazione della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna una causale contabile esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { nome, descrizione, externalId } = req.body;\n    \n    const causale = await prisma.causaleContabile.update({\n      where: { id },\n      data: {\n        nome,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(causale);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina una causale contabile\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.causaleContabile.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione della causale contabile:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "clienti.ts",
          "type": "file",
          "token_estimate": 702,
          "content": "import express, { Router, Request, Response } from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\n\nconst router = Router();\nconst prisma = new PrismaClient();\n\n// Funzione helper per gestire gli errori Prisma\nconst isPrismaError = (error: unknown): error is PrismaClientKnownRequestError => {\n    return error instanceof PrismaClientKnownRequestError;\n};\n\n// --- CRUD Clienti ---\nrouter.post('/', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome Ã¨ obbligatorio' });\n      return;\n    }\n    const nuovoCliente = await prisma.cliente.create({\n      data: {\n        nome,\n        externalId,\n      },\n    });\n    res.status(201).json(nuovoCliente);\n  } catch (error) {\n    console.error('Errore nella creazione del cliente:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {\n      res.status(409).json({ error: 'Un cliente con questa P.IVA o nome esiste giÃ .' });\n      return;\n    }\n    res.status(500).json({ error: \"Errore durante la creazione del cliente.\" });\n  }\n});\n\nrouter.put('/:id', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { id } = req.params;\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome Ã¨ obbligatorio' });\n      return;\n    }\n    const clienteAggiornato = await prisma.cliente.update({\n      where: { id },\n      data: {\n        nome,\n        externalId,\n      },\n    });\n    res.json(clienteAggiornato);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del cliente:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {\n        res.status(404).json({ error: 'Cliente non trovato.' });\n        return;\n    }\n    res.status(500).json({ error: \"Errore durante l'aggiornamento del cliente.\" });\n  }\n});\n\nrouter.delete('/:id', async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { id } = req.params;\n    await prisma.cliente.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    if (error instanceof PrismaClientKnownRequestError) {\n      if (error.code === 'P2025') {\n          res.status(404).json({ error: 'Cliente non trovato.' });\n          return;\n      }\n      if (error.code === 'P2003') {\n        res.status(409).json({ error: 'Impossibile eliminare il cliente perchÃ© Ã¨ associato ad almeno una commessa.' });\n        return;\n      }\n    }\n    console.error('Errore nell\\'eliminazione del cliente:', error);\n    res.status(500).json({ error: \"Errore durante l'eliminazione del cliente.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "codiciIva.ts",
          "type": "file",
          "token_estimate": 520,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutti i codici IVA\nrouter.get('/', async (req, res) => {\n  try {\n    const codiciIva = await prisma.codiceIva.findMany({\n      orderBy: {\n        id: 'asc'\n      }\n    });\n    res.json(codiciIva);\n  } catch (error) {\n    console.error('Errore nel caricamento dei codici IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea un nuovo codice IVA\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, descrizione, aliquota, externalId } = req.body;\n    \n    const codiceIva = await prisma.codiceIva.create({\n      data: {\n        id,\n        descrizione,\n        aliquota: parseFloat(aliquota),\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(codiceIva);\n  } catch (error) {\n    console.error('Errore nella creazione del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna un codice IVA esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { descrizione, aliquota, externalId } = req.body;\n    \n    const codiceIva = await prisma.codiceIva.update({\n      where: { id },\n      data: {\n        descrizione,\n        aliquota: parseFloat(aliquota),\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(codiceIva);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina un codice IVA\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.codiceIva.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione del codice IVA:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "commesse.ts",
          "type": "file",
          "token_estimate": 611,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all commesse\nrouter.get('/', async (req, res) => {\n  try {\n    const commesse = await prisma.commessa.findMany({\n      include: { \n        cliente: true, \n        budget: true \n      }\n    });\n    res.json(commesse);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel recupero delle commesse.' });\n  }\n});\n\n// POST a new commessa\nrouter.post('/', async (req, res) => {\n  try {\n    const { budget, ...commessaData } = req.body;\n    const nuovaCommessa = await prisma.commessa.create({\n      data: {\n        ...commessaData,\n        budget: {\n          create: budget || [], // budget Ã¨ un array di BudgetVoce\n        }\n      },\n    });\n    res.status(201).json(nuovaCommessa);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Errore nella creazione della commessa.' });\n  }\n});\n\n// PUT update a commessa\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const { budget, cliente, ...commessaData } = req.body;\n    \n    // Iniziamo una transazione per aggiornare la commessa e il suo budget\n    const result = await prisma.$transaction(async (tx) => {\n      // 1. Aggiorna i dati base della commessa\n      const commessaAggiornata = await tx.commessa.update({\n        where: { id },\n        data: commessaData,\n      });\n\n      // 2. Se Ã¨ stato fornito un nuovo budget, cancelliamo quello vecchio e creiamo quello nuovo\n      if (budget) {\n        await tx.budgetVoce.deleteMany({\n          where: { commessaId: id },\n        });\n        await tx.budgetVoce.createMany({\n          data: budget.map((voce: any) => ({\n            ...voce,\n            commessaId: id,\n          })),\n        });\n      }\n\n      return commessaAggiornata;\n    });\n\n    res.json(result);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: `Errore nell'aggiornamento della commessa ${id}.` });\n  }\n});\n\n// DELETE a commessa\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    // La cancellazione a cascata dovrebbe gestire il budget associato\n    await prisma.commessa.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione della commessa ${id}.` });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "condizioniPagamento.ts",
          "type": "file",
          "token_estimate": 549,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET - Recupera tutte le condizioni di pagamento\nrouter.get('/', async (req, res) => {\n  try {\n    const condizioniPagamento = await prisma.condizionePagamento.findMany({\n      orderBy: {\n        id: 'asc'\n      }\n    });\n    res.json(condizioniPagamento);\n  } catch (error) {\n    console.error('Errore nel caricamento delle condizioni di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// POST - Crea una nuova condizione di pagamento\nrouter.post('/', async (req, res) => {\n  try {\n    const { id, descrizione, externalId } = req.body;\n    \n    const condizionePagamento = await prisma.condizionePagamento.create({\n      data: {\n        id,\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.status(201).json(condizionePagamento);\n  } catch (error) {\n    console.error('Errore nella creazione della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// PUT - Aggiorna una condizione di pagamento esistente\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { descrizione, externalId } = req.body;\n    \n    const condizionePagamento = await prisma.condizionePagamento.update({\n      where: { id },\n      data: {\n        descrizione,\n        externalId: externalId || null,\n      }\n    });\n    \n    res.json(condizionePagamento);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\n// DELETE - Elimina una condizione di pagamento\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    await prisma.condizionePagamento.delete({\n      where: { id }\n    });\n    \n    res.status(204).send();\n  } catch (error) {\n    console.error('Errore nell\\'eliminazione della condizione di pagamento:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "conti.ts",
          "type": "file",
          "token_estimate": 336,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all conti\nrouter.get('/', async (req, res) => {\n  try {\n    const conti = await prisma.conto.findMany();\n    res.json(conti);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel recupero dei conti.' });\n  }\n});\n\n// POST a new conto\nrouter.post('/', async (req, res) => {\n  try {\n    const nuovoConto = await prisma.conto.create({\n      data: req.body,\n    });\n    res.status(201).json(nuovoConto);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nella creazione del conto.' });\n  }\n});\n\n// PUT update a conto\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const contoAggiornato = await prisma.conto.update({\n      where: { id },\n      data: req.body,\n    });\n    res.json(contoAggiornato);\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'aggiornamento del conto ${id}.` });\n  }\n});\n\n// DELETE a conto\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    await prisma.conto.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione del conto ${id}.` });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "dashboard.ts",
          "type": "file",
          "token_estimate": 733,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\n// Tipi incollati da src/types/index.ts per risolvere l'errore di rootDir\ninterface CommessaDashboard {\n  id: string;\n  nome: string;\n  cliente: {\n    id: string;\n    nome: string;\n  };\n  stato: string;\n  ricavi: number;\n  costi: number;\n  margine: number;\n  budget: number;\n}\n\ninterface DashboardData {\n  commesse: CommessaDashboard[];\n  kpi: {\n    commesseAttive: number;\n    ricaviTotali: number;\n    costiTotali: number;\n    margineLordoMedio: number;\n  };\n}\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\nrouter.get('/', async (req, res) => {\n  try {\n    const commesse = await prisma.commessa.findMany({\n      include: {\n        cliente: true,\n        budget: {\n          include: {\n            voceAnalitica: true,\n          },\n        },\n        allocazioni: {\n          include: {\n            rigaScrittura: true,\n          },\n        },\n      },\n    });\n\n    const scritture = await prisma.scritturaContabile.findMany({\n      include: {\n        righe: {\n          include: {\n            conto: true,\n            allocazioni: {\n              include: {\n                commessa: true,\n                voceAnalitica: true,\n              }\n            }\n          }\n        }\n      }\n    });\n\n    const commesseDashboard: CommessaDashboard[] = commesse.map(c => {\n      const budgetTotale = c.budget.reduce((acc, b) => acc + b.importo, 0);\n      \n      const costi = scritture.flatMap(s => s.righe)\n        .filter(r => r.conto.tipo === 'Costo' && r.allocazioni.some(a => a.commessaId === c.id))\n        .reduce((acc, r) => acc + r.dare, 0);\n\n      const ricavi = scritture.flatMap(s => s.righe)\n        .filter(r => r.conto.tipo === 'Ricavo' && r.allocazioni.some(a => a.commessaId === c.id))\n        .reduce((acc, r) => acc + r.avere, 0);\n\n      const margine = ricavi > 0 ? ((ricavi - costi) / ricavi) * 100 : 0;\n\n      return {\n        id: c.id,\n        nome: c.nome,\n        cliente: {\n            id: c.cliente.id,\n            nome: c.cliente.nome,\n        },\n        stato: 'In Corso',\n        ricavi: ricavi,\n        costi: costi,\n        margine: margine,\n        budget: budgetTotale\n      };\n    });\n\n    const ricaviTotali = commesseDashboard.reduce((acc, c) => acc + c.ricavi, 0);\n    const costiTotali = commesseDashboard.reduce((acc, c) => acc + c.costi, 0);\n    const margineLordoMedio = ricaviTotali > 0 ? ((ricaviTotali - costiTotali) / ricaviTotali) * 100 : 0;\n\n    const dashboardData: DashboardData = {\n      kpi: {\n        commesseAttive: commesse.length,\n        ricaviTotali,\n        costiTotali,\n        margineLordoMedio,\n      },\n      commesse: commesseDashboard,\n    };\n\n    res.json(dashboardData);\n  } catch (error) {\n    console.error(\"Errore nel recupero dati per la dashboard:\", error);\n    res.status(500).json({ message: \"Errore interno del server.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "database.ts",
          "type": "file",
          "token_estimate": 617,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\nrouter.get('/', async (req, res) => {\n  try {\n    const [\n      scritture,\n      commesse,\n      clienti,\n      fornitori,\n      conti,\n      vociAnalitiche,\n      causali,\n      codiciIva,\n      condizioniPagamento,\n    ] = await prisma.$transaction([\n      prisma.scritturaContabile.findMany({\n        include: {\n          righe: true\n        },\n        orderBy: {\n            data: 'desc'\n        }\n      }),\n      prisma.commessa.findMany(),\n      prisma.cliente.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.fornitore.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.conto.findMany({ orderBy: { codice: 'asc' } }),\n      prisma.voceAnalitica.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.causaleContabile.findMany({ orderBy: { nome: 'asc' } }),\n      prisma.codiceIva.findMany({ orderBy: { id: 'asc' } }),\n      prisma.condizionePagamento.findMany({ orderBy: { id: 'asc' } }),\n    ]);\n\n    const stats = {\n      totaleScrittureContabili: scritture.length,\n      totaleCommesse: commesse.length,\n      totaleClienti: clienti.length,\n      totaleFornitori: fornitori.length,\n      totaleConti: conti.length,\n      totaleVociAnalitiche: vociAnalitiche.length,\n      totaleCausali: causali.length,\n      totaleCodiciIva: codiciIva.length,\n      totaleCondizioniPagamento: condizioniPagamento.length,\n    };\n\n    res.json({\n      scritture,\n      commesse,\n      clienti,\n      fornitori,\n      conti,\n      vociAnalitiche,\n      causali,\n      codiciIva,\n      condizioniPagamento,\n      stats,\n    });\n  } catch (error) {\n    console.error('Errore nel recupero dei dati del database:', error);\n    res.status(500).json({ error: 'Errore interno del server' });\n  }\n});\n\nrouter.delete('/scritture', async (req, res) => {\n  try {\n    await prisma.$transaction(async (tx) => {\n      await tx.allocazione.deleteMany({});\n      await tx.rigaIva.deleteMany({});\n      await tx.rigaScrittura.deleteMany({});\n      await tx.scritturaContabile.deleteMany({});\n    });\n    res.status(200).json({ message: 'Tabella Scritture Contabili svuotata con successo.' });\n  } catch (error) {\n    console.error(\"Errore durante lo svuotamento della tabella Scritture Contabili:\", error);\n    res.status(500).json({ error: 'Errore interno del server durante la pulizia delle scritture.' });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "fornitori.ts",
          "type": "file",
          "token_estimate": 708,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// Funzione helper per gestire gli errori Prisma\nconst isPrismaError = (error: unknown): error is PrismaClientKnownRequestError => {\n    return error instanceof PrismaClientKnownRequestError;\n};\n\n// --- CRUD Fornitori ---\nrouter.post('/', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome Ã¨ obbligatorio' });\n      return;\n    }\n    const nuovoFornitore = await prisma.fornitore.create({ \n      data: {\n        nome,\n        externalId\n      }\n    });\n    res.status(201).json(nuovoFornitore);\n  } catch (error) {\n    console.error('Errore nella creazione del fornitore:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {\n      res.status(409).json({ error: 'Un fornitore con questa P.IVA o nome esiste giÃ .' });\n      return;\n    }\n    res.status(500).json({ error: \"Errore durante la creazione del fornitore.\" });\n  }\n});\n\nrouter.put('/:id', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    const { nome, externalId } = req.body;\n    if (!nome) {\n      res.status(400).json({ error: 'Il nome Ã¨ obbligatorio' });\n      return;\n    }\n    const fornitoreAggiornato = await prisma.fornitore.update({\n      where: { id: req.params.id },\n      data: {\n        nome,\n        externalId\n      },\n    });\n    res.json(fornitoreAggiornato);\n  } catch (error) {\n    console.error('Errore nell\\'aggiornamento del fornitore:', error);\n    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {\n        res.status(404).json({ error: 'Fornitore non trovato.' });\n        return;\n    }\n    res.status(500).json({ error: \"Errore durante l'aggiornamento del fornitore.\" });\n  }\n});\n\nrouter.delete('/:id', async (req: express.Request, res: express.Response): Promise<void> => {\n  try {\n    await prisma.fornitore.delete({ where: { id: req.params.id } });\n    res.status(204).send();\n  } catch (error) {\n    if (error instanceof PrismaClientKnownRequestError) {\n      if (error.code === 'P2025') {\n          res.status(404).json({ error: 'Fornitore non trovato.' });\n          return;\n      }\n      if (error.code === 'P2003') {\n        res.status(409).json({ error: 'Impossibile eliminare il fornitore perchÃ© Ã¨ utilizzato in una o piÃ¹ registrazioni.' });\n        return;\n      }\n    }\n    console.error('Errore nell\\'eliminazione del fornitore:', error);\n    res.status(500).json({ error: \"Errore durante l'eliminazione del fornitore.\" });\n  }\n});\n\nexport default router; "
        },
        {
          "name": "importAnagrafiche.ts",
          "type": "file",
          "token_estimate": 1401,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient, Prisma, TipoConto } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\nrouter.post('/:templateName', upload.single('file'), async (req: Request, res: Response) => {\n    const { templateName } = req.params;\n\n    if (!req.file) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n    \n    const file = req.file;\n\n    try {\n        // 1. Recupera il template e le definizioni dal DB\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: templateName },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            return res.status(404).json({ error: `Template '${templateName}' non trovato.` });\n        }\n\n        const modelName = (importTemplate as any).modelName as keyof PrismaClient;\n        const fileContent = file.buffer.toString('utf-8');\n        const fieldDefinitions = importTemplate.fields.map(f => ({ name: f.nomeCampo, start: f.start, length: f.length, type: f.type as any }));\n        const parsedData = parseFixedWidth<any>(fileContent, fieldDefinitions);\n\n        // Gestione speciale per clienti/fornitori\n        if (templateName === 'clienti_fornitori') {\n            await prisma.$transaction(async (tx) => {\n                for (const record of parsedData) {\n                    const piva = record.piva?.trim();\n\n                    // Se la P.IVA non Ã¨ valida o Ã¨ vuota, salta il record per sicurezza\n                    if (!piva || piva.length < 11) { \n                        continue;\n                    }\n\n                    const dataToUpsert = {\n                        id: record.externalId.trim(),\n                        externalId: record.externalId.trim(),\n                        nome: record.nome.trim(),\n                        piva: piva,\n                        codiceFiscale: record.codiceFiscale?.trim(),\n                    };\n                    \n                    const targetModel = record.tipo === 'C' ? tx.cliente : tx.fornitore;\n                    \n                    // Controlla se esiste giÃ  un record con questa PIVA prima di fare upsert\n                    const existing = await (targetModel as any).findUnique({\n                        where: { piva: dataToUpsert.piva },\n                    });\n\n                    // Se non esiste, procedi con l'upsert usando l'ID esterno come chiave principale\n                    if (!existing) {\n                        await (targetModel as any).upsert({\n                            where: { id: dataToUpsert.id },\n                            update: dataToUpsert,\n                            create: dataToUpsert,\n                        });\n                    }\n                }\n            });\n             return res.status(200).json({ message: `Importazione per '${templateName}' completata. Record duplicati o non validi sono stati ignorati.` });\n        }\n\n        // Gestione per Piano dei Conti\n        if (templateName === 'piano_dei_conti') {\n            const contiDaImportare = parsedData\n                .filter(record => record.tipo_soggetto !== 'C' && record.tipo_soggetto !== 'F' && record.id.trim())\n                .map(record => ({\n                    id: record.id.trim(),\n                    codice: record.id.trim(),\n                    nome: record.nome.trim() || 'N/A',\n                    tipo: TipoConto.Patrimoniale, // Default, andrÃ  classificato meglio in futuro\n                    richiedeVoceAnalitica: false,\n                }));\n\n            await prisma.$transaction(async (tx) => {\n                for (const conto of contiDaImportare) {\n                    await tx.conto.upsert({\n                        where: { id: conto.id },\n                        update: { nome: conto.nome },\n                        create: conto,\n                    });\n                }\n            });\n            return res.status(200).json({ message: `Importazione per '${templateName}' completata. ${contiDaImportare.length} conti processati.` });\n        }\n\n        if (!modelName || !(prisma as any)[modelName]) {\n            return res.status(400).json({ error: `Il nome del modello per '${templateName}' non Ã¨ valido o non Ã¨ configurato.` });\n        }\n\n        // Esegui il parsing e il salvataggio per anagrafiche generiche\n        await prisma.$transaction(async (tx) => {\n            for (const record of parsedData) {\n                const dataToUpsert = { ...record };\n                Object.keys(dataToUpsert).forEach(key => {\n                    if (typeof dataToUpsert[key] === 'string') {\n                        dataToUpsert[key] = dataToUpsert[key].trim();\n                    }\n                });\n\n                if (!dataToUpsert.id) continue;\n\n                await (tx as any)[modelName].upsert({\n                    where: { id: dataToUpsert.id },\n                    update: dataToUpsert,\n                    create: dataToUpsert,\n                });\n            }\n        });\n\n        return res.status(200).json({ message: `Importazione per '${templateName}' completata. ${parsedData.length} record processati.` });\n\n    } catch (error: any) {\n        console.error(`Errore durante l'importazione per '${templateName}':`, error);\n        res.status(500).json({ error: \"Errore interno del server durante l'importazione.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importScritture.ts",
          "type": "file",
          "token_estimate": 1039,
          "content": "import express, { Request, Response } from 'express';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport { parseFixedWidth, FieldDefinition } from '../lib/fixedWidthParser';\nimport { processScrittureInBatches } from '../lib/importUtils.js';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\nconst upload = multer({ storage: multer.memoryStorage() });\n\nrouter.post('/', upload.array('files', 10), async (req: Request, res: Response) => {\n    if (!req.files || (req.files as Express.Multer.File[]).length === 0) {\n        return res.status(400).json({ error: 'Nessun file caricato.' });\n    }\n    \n    const files = req.files as Express.Multer.File[];\n\n    try {\n        // 1. Recupera il template e le definizioni dal DB\n        const importTemplate = await prisma.importTemplate.findUnique({\n            where: { nome: 'scritture_contabili' },\n            include: { fields: true },\n        });\n\n        if (!importTemplate) {\n            return res.status(404).json({ error: \"Template 'scritture_contabili' non trovato.\" });\n        }\n        \n        // 2. Raggruppa le definizioni per fileIdentifier\n        const definitionsByFile = importTemplate.fields.reduce((acc, field) => {\n            const key = (field as any).fileIdentifier || 'default';\n            if (!acc[key]) {\n                acc[key] = [];\n            }\n            acc[key].push({\n                name: field.nomeCampo,\n                start: field.start,\n                length: field.length,\n                type: field.type as 'string' | 'number' | 'date',\n            });\n            return acc;\n        }, {} as Record<string, FieldDefinition[]>);\n\n        // 3. Associa i file caricati alle loro definizioni\n        const filesByDefinition = Object.keys(definitionsByFile).reduce((acc, key) => {\n            const file = files.find(f => f.originalname === key);\n            if (file) {\n                acc[key] = {\n                    file,\n                    definitions: definitionsByFile[key]\n                };\n            }\n            return acc;\n        }, {} as Record<string, { file: Express.Multer.File, definitions: FieldDefinition[] }>);\n\n        console.log('File trovati e associati:', Object.keys(filesByDefinition));\n\n        // VERIFICA: Assicurarsi che tutti i file necessari siano presenti\n        const requiredFiles = ['PNTESTA.TXT', 'PNRIGCON.TXT']; // PNRIGANA.TXT Ã¨ opzionale\n        for (const requiredFile of requiredFiles) {\n            if (!filesByDefinition[requiredFile]) {\n                return res.status(400).json({ error: `File mancante: ${requiredFile} Ã¨ richiesto per questa importazione.` });\n            }\n        }\n\n        // 4. Esegui il parsing per ogni file\n        const testate = parseFixedWidth<any>(filesByDefinition['PNTESTA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNTESTA.TXT'].definitions);\n        const righeContabili = parseFixedWidth<any>(filesByDefinition['PNRIGCON.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGCON.TXT'].definitions);\n        \n        let righeIva: any[] = [];\n        if (filesByDefinition['PNRIGIVA.TXT']) {\n            righeIva = parseFixedWidth<any>(filesByDefinition['PNRIGIVA.TXT'].file.buffer.toString('utf-8'), filesByDefinition['PNRIGIVA.TXT'].definitions);\n        }\n\n        let allocazioni: any[] = [];\n        if (filesByDefinition['MOVANAC.TXT']) {\n            allocazioni = parseFixedWidth<any>(filesByDefinition['MOVANAC.TXT'].file.buffer.toString('utf-8'), filesByDefinition['MOVANAC.TXT'].definitions);\n        }\n\n        // 5. Salva i dati in una transazione\n        const summary = await processScrittureInBatches({ testate, righeContabili, righeIva, allocazioni });\n\n        return res.status(200).json({ \n            message: `Importazione completata. ${summary.processedCount} record processati, ${summary.errorCount} errori.`,\n            summary\n        });\n\n    } catch (error: any) {\n        console.error(\"Errore durante l'importazione delle scritture:\", error);\n        res.status(500).json({ error: \"Errore interno del server durante l'importazione.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "importTemplates.ts",
          "type": "file",
          "token_estimate": 1247,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET all import templates\nrouter.get('/', async (req, res) => {\n    try {\n        const templates = await prisma.importTemplate.findMany({\n            include: { fields: true },\n            orderBy: { nome: 'asc' }\n        });\n        res.json(templates);\n    } catch (error) {\n        console.error(\"Errore nel recupero dei template di importazione:\", error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// POST a new import template\nrouter.post('/', async (req, res) => {\n    const { nome, fields } = req.body;\n\n    if (!nome || !fields) {\n        return res.status(400).json({ error: \"Il nome e i campi del template sono obbligatori.\" });\n    }\n\n    try {\n        const newTemplate = await prisma.importTemplate.create({\n            data: {\n                nome,\n                fields: {\n                    create: fields.map((field: any) => ({\n                        nomeCampo: field.nomeCampo,\n                        start: parseInt(field.start, 10),\n                        length: parseInt(field.length, 10),\n                        type: field.type,\n                        fileIdentifier: field.fileIdentifier || null\n                    } as any))\n                }\n            },\n            include: { fields: true }\n        });\n        res.status(201).json(newTemplate);\n    } catch (error) {\n        console.error(\"Errore nella creazione del template:\", error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// PUT (update) an import template\nrouter.put('/:id', async (req, res) => {\n    const { id } = req.params;\n    const { nome, fields } = req.body;\n\n    if (!nome || !fields) {\n        return res.status(400).json({ error: \"Il nome e i campi del template sono obbligatori.\" });\n    }\n\n    try {\n        const updatedTemplate = await prisma.$transaction(async (tx) => {\n            // 1. Aggiorna il nome del template\n            const template = await tx.importTemplate.update({\n                where: { id },\n                data: { nome }\n            });\n\n            const existingFields = await tx.fieldDefinition.findMany({ where: { templateId: id } });\n            const existingFieldIds = new Set(existingFields.map(f => f.id));\n            const incomingFieldIds = new Set(fields.map((f: any) => f.id).filter(Boolean));\n\n            // 2. Identifica i campi da eliminare\n            const fieldsToDelete = [...existingFieldIds].filter(fieldId => !incomingFieldIds.has(fieldId));\n            if (fieldsToDelete.length > 0) {\n                await tx.fieldDefinition.deleteMany({\n                    where: { id: { in: fieldsToDelete } }\n                });\n            }\n\n            // 3. Aggiorna o crea i campi\n            for (const field of fields) {\n                if (field.id && existingFieldIds.has(field.id)) {\n                    // Aggiorna campo esistente\n                    await tx.fieldDefinition.update({\n                        where: { id: field.id },\n                        data: {\n                            nomeCampo: field.nomeCampo,\n                            start: parseInt(field.start, 10),\n                            length: parseInt(field.length, 10),\n                            type: field.type,\n                            fileIdentifier: field.fileIdentifier || null\n                        } as any\n                    });\n                } else {\n                    // Crea nuovo campo\n                    await tx.fieldDefinition.create({\n                        data: {\n                            templateId: id,\n                            nomeCampo: field.nomeCampo,\n                            start: parseInt(field.start, 10),\n                            length: parseInt(field.length, 10),\n                            type: field.type,\n                            fileIdentifier: field.fileIdentifier || null\n                        } as any\n                    });\n                }\n            }\n\n            return tx.importTemplate.findUnique({\n                where: { id },\n                include: { fields: true }\n            });\n        });\n\n        res.json(updatedTemplate);\n\n    } catch (error) {\n        console.error(`Errore nell'aggiornamento del template ${id}:`, error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\n// DELETE an import template\nrouter.delete('/:id', async (req, res) => {\n    const { id } = req.params;\n    try {\n        // La cancellazione a cascata Ã¨ gestita da Prisma in base allo schema\n        await prisma.importTemplate.delete({\n            where: { id }\n        });\n        res.status(204).send();\n    } catch (error) {\n        console.error(`Errore nella cancellazione del template ${id}:`, error);\n        res.status(500).json({ error: \"Errore interno del server.\" });\n    }\n});\n\nexport default router; "
        },
        {
          "name": "registrazioni.ts",
          "type": "file",
          "token_estimate": 1040,
          "content": "import express from 'express';\nimport { PrismaClient, Prisma } from '@prisma/client';\n\n// Tipi incollati per evitare errore rootDir\ninterface ScritturaContabile {\n  id: string;\n  data: string; \n  causaleId: string;\n  descrizione: string;\n  righe: RigaScrittura[];\n  datiAggiuntivi?: {\n    fornitoreId?: string | null;\n    clienteId?: string | null;\n    totaleFattura?: number | string;\n    aliquotaIva?: number;\n  };\n}\n\ninterface RigaScrittura {\n  id: string;\n  descrizione: string;\n  dare: number;\n  avere: number;\n  contoId: string;\n  allocazioni: Allocazione[];\n}\n\ninterface Allocazione {\n  id: string;\n  commessaId: string;\n  voceAnaliticaId: string;\n  importo: number;\n  descrizione?: string;\n}\n\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// GET all\nrouter.get('/', async (req, res) => {\n  try {\n    const scritture = await prisma.scritturaContabile.findMany({\n      include: { righe: { include: { conto: true, allocazioni: true } } },\n      orderBy: { data: 'desc' },\n    });\n    res.json(scritture);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel caricamento delle scritture' });\n  }\n});\n\n// GET by ID\nrouter.get('/:id', async (req, res) => {\n    try {\n        const scrittura = await prisma.scritturaContabile.findUnique({\n            where: { id: req.params.id },\n            include: { righe: { include: { conto: true, allocazioni: true } } },\n        });\n        if (!scrittura) return res.status(404).json({ error: 'Scrittura non trovata' });\n        res.json(scrittura);\n    } catch (error) {\n        res.status(500).json({ error: 'Errore nel caricamento della scrittura' });\n    }\n});\n\n\n// POST (Create)\nrouter.post('/', async (req, res) => {\n    const { righe, ...data } = req.body as ScritturaContabile;\n    try {\n        const nuovaScrittura = await prisma.scritturaContabile.create({\n            data: {\n                ...data,\n                data: new Date(data.data),\n                righe: {\n                    create: righe.map(riga => ({\n                        ...riga,\n                        allocazioni: {\n                            create: riga.allocazioni || [],\n                        }\n                    }))\n                }\n            },\n            include: { righe: true }\n        });\n        res.status(201).json(nuovaScrittura);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Errore nella creazione della scrittura' });\n    }\n});\n\n// PUT (Update)\nrouter.put('/:id', async (req, res) => {\n    const { id } = req.params;\n    const { righe, ...data } = req.body as ScritturaContabile;\n    try {\n        // Transazione per aggiornare: cancella le vecchie righe e crea le nuove\n        const updatedScrittura = await prisma.$transaction(async (tx) => {\n            await tx.rigaScrittura.deleteMany({ where: { scritturaContabileId: id }});\n            \n            return tx.scritturaContabile.update({\n                where: { id },\n                data: {\n                    ...data,\n                    data: new Date(data.data),\n                    righe: {\n                        create: righe.map(riga => ({\n                            descrizione: riga.descrizione,\n                            dare: riga.dare,\n                            avere: riga.avere,\n                            contoId: riga.contoId,\n                            allocazioni: {\n                                create: riga.allocazioni || [],\n                            }\n                        }))\n                    }\n                },\n                 include: { righe: { include: { allocazioni: true }}}\n            });\n        });\n        res.json(updatedScrittura);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Errore nell\\'aggiornamento della scrittura' });\n    }\n});\n\n\n// DELETE\nrouter.delete('/:id', async (req, res) => {\n    try {\n        await prisma.scritturaContabile.delete({ where: { id: req.params.id } });\n        res.status(204).send();\n    } catch (error) {\n        res.status(500).json({ error: 'Errore nell\\'eliminazione della scrittura' });\n    }\n});\n\n\nexport default router; "
        },
        {
          "name": "vociAnalitiche.ts",
          "type": "file",
          "token_estimate": 368,
          "content": "import express from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst router = express.Router();\n\n// GET all voci analitiche\nrouter.get('/', async (req, res) => {\n  try {\n    const vociAnalitiche = await prisma.voceAnalitica.findMany();\n    res.json(vociAnalitiche);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nel recupero delle voci analitiche.' });\n  }\n});\n\n// POST a new voce analitica\nrouter.post('/', async (req, res) => {\n  try {\n    const nuovaVoce = await prisma.voceAnalitica.create({\n      data: req.body,\n    });\n    res.status(201).json(nuovaVoce);\n  } catch (error) {\n    res.status(500).json({ error: 'Errore nella creazione della voce analitica.' });\n  }\n});\n\n// PUT update a voce analitica\nrouter.put('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    const voceAggiornata = await prisma.voceAnalitica.update({\n      where: { id },\n      data: req.body,\n    });\n    res.json(voceAggiornata);\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'aggiornamento della voce analitica ${id}.` });\n  }\n});\n\n// DELETE a voce analitica\nrouter.delete('/:id', async (req, res) => {\n  const { id } = req.params;\n  try {\n    await prisma.voceAnalitica.delete({\n      where: { id },\n    });\n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: `Errore nell'eliminazione della voce analitica ${id}.` });\n  }\n});\n\nexport default router; "
        }
      ]
    },
    {
      "name": "tsconfig.json",
      "type": "file",
      "token_estimate": 203,
      "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": false,\n    \"removeComments\": true,\n    \"noImplicitAny\": false,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitThis\": true,\n    \"noImplicitReturns\": false,\n    \"noFallthroughCasesInSwitch\": true,\n    \"moduleResolution\": \"node\",\n    \"allowJs\": true,\n    \"checkJs\": false,\n    \"isolatedModules\": true\n  },\n  \"ts-node\": {\n    \"esm\": true\n  },\n  \"include\": [\n    \"**/*.ts\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\"\n  ]\n} "
    }
  ]
}